// Copyright (c) Narvalo.Org. All rights reserved. See LICENSE.txt in the project root for license information.

//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by a tool. Changes to this file may cause incorrect
// behavior and will be lost if the code is regenerated.
//
// Runtime Version: 4.0.30319.42000
// Microsoft.VisualStudio.TextTemplating: 15.0
// </auto-generated>
//------------------------------------------------------------------------------

namespace Narvalo.Applicative {
    using System;
    using System.Linq;

    using FsCheck.Xunit;
    using Narvalo.Linq;
    using Xunit;

    // T4: EmitMonadCore().
    public static partial class OutcomeFacts {
        internal sealed class tAttribute : FactAttribute {
            public tAttribute(string description) : base() {
                DisplayName = nameof(Outcome) + " - " + description;
            }
        }

        internal sealed class TAttribute : TheoryAttribute {
            public TAttribute(string description) : base() {
                DisplayName = nameof(Outcome) + " - " + description;
            }
        }

        internal sealed class qAttribute : PropertyAttribute {
            public qAttribute(string description) : base() {
                DisplayName = nameof(Outcome) + " - " + description;
            }
        }

        [q("Ap.Apply is Select.Gather w/ the arguments flipped.")]
        public static bool Apply01(int arg0, long arg1) {
            var applicative = Outcome<Func<int, long>>.η(i => arg1 * i);
            var value = Outcome<int>.η(arg0);

            var applied = applicative.Apply(value);
            var gathered = value.Gather(applicative);

            return applied.Equals(gathered);
        }

        [q("Kleisli.InvokeWith is Qperators.SelectWith w/ the arguments flipped.", Skip = "Needs some more work.")]
        public static bool InvokeWith01(int arg0, long arg1, int arg3) {
            Func<int, Outcome<long>> selector = i => Outcome<long>.η(arg1 * i);
            var seq = Enumerable.Repeat(arg0, arg3);

            var invoked = selector.InvokeWith(seq);
            var selected = seq.SelectWith(selector);

            var q = from x in invoked
                    from y in selected
                    select Enumerable.SequenceEqual(x, y);

            return q.Value;
        }

        [q("Kleisli.InvokeWith is Outcome.Bind w/ the arguments flipped.")]
        public static bool InvokeWith02(int arg0, long arg1) {
            Func<int, Outcome<long>> binder = i => Outcome<long>.η(arg1 * i);
            var value = Outcome<int>.η(arg0);

            var invoked = binder.InvokeWith(value);
            var bounded = value.Bind(binder);

            return invoked.Equals(bounded);
        }
    }

#if !NO_INTERNALS_VISIBLE_TO

    // Provides tests for Outcome<T>.
    // T4: EmitMonadGuards().
    public static partial class OutcomeFacts {
        [t("Compose() guards.")]
        public static void Compose0() {
            Func<int, Outcome<int>> first = null;
            Func<int, Outcome<int>> second = i => Outcome<int>.η(1);

            Assert.Throws<ArgumentNullException>("this", () => first.Compose(second));
        }

        [t("Compose() guards.")]
        public static void ComposeBack0() {
            Func<int, Outcome<int>> first = i => Outcome<int>.η(1);
            Func<int, Outcome<int>> second = null;

            Assert.Throws<ArgumentNullException>("second", () => first.ComposeBack(second));
        }

        [t("Repeat() guards.")]
        public static void Repeat0() {
            var source = Outcome<int>.η(1);

            Assert.Throws<ArgumentOutOfRangeException>("count", () => Outcome.Repeat(source, -1));
        }

        [t("Zip() guards.")]
        public static void Zip0() {
            var first = Outcome<int>.η(1);
            var second = Outcome<int>.η(2);
            var third = Outcome<int>.η(3);
            var fourth = Outcome<int>.η(4);
            var fifth = Outcome<int>.η(5);
            Func<int, int, int> zipper2 = null;
            Func<int, int, int, int> zipper3 = null;
            Func<int, int, int, int, int> zipper4 = null;
            Func<int, int, int, int, int, int> zipper5 = null;

            // Extension method.
            Assert.Throws<ArgumentNullException>("zipper", () => first.Zip(second, zipper2));
            Assert.Throws<ArgumentNullException>("zipper", () => first.Zip(second, third, zipper3));
            Assert.Throws<ArgumentNullException>("zipper", () => first.Zip(second, third, fourth, zipper4));
            Assert.Throws<ArgumentNullException>("zipper", () => first.Zip(second, third, fourth, fifth, zipper5));
            // Static method.
            Assert.Throws<ArgumentNullException>("zipper", () => OutcomeExtensions.Zip(first, second, zipper2));
            Assert.Throws<ArgumentNullException>("zipper", () => OutcomeExtensions.Zip(first, second, third, zipper3));
            Assert.Throws<ArgumentNullException>("zipper", () => OutcomeExtensions.Zip(first, second, third, fourth, zipper4));
            Assert.Throws<ArgumentNullException>("zipper", () => OutcomeExtensions.Zip(first, second, third, fourth, fifth, zipper5));
        }

        [t("Select() guards.")]
        public static void Select0() {
            var source = Outcome<int>.η(1);
            Func<int, long> selector = null;

            Assert.Throws<ArgumentNullException>("selector", () => source.Select(selector));
            Assert.Throws<ArgumentNullException>("selector", () => OutcomeExtensions.Select(source, selector));
        }

        [t("SelectMany() guards.")]
        public static void SelectMany0() {
            var source = Outcome<short>.η(1);
            var middle = Outcome<int>.η(2);
            Func<short, Outcome<int>> valueSelector = i => Outcome<int>.η(i);
            Func<short, int, long> resultSelector = (i, j) => i + j;

            // Extension method.
            Assert.Throws<ArgumentNullException>("selector", () => source.SelectMany(null, resultSelector));
            Assert.Throws<ArgumentNullException>("resultSelector", () => source.SelectMany(valueSelector, (Func<short, int, long>)null));
            // Static method.
            Assert.Throws<ArgumentNullException>("selector", () => OutcomeExtensions.SelectMany(source, null, resultSelector));
            Assert.Throws<ArgumentNullException>("resultSelector", () => OutcomeExtensions.SelectMany(source, valueSelector, (Func<short, int, long>)null));
        }

    }

#endif

#if !NO_INTERNALS_VISIBLE_TO

    // Provides tests for Outcome<T>: functor, monoid and monad laws.
    // T4: EmitMonadRules().
    public static partial class OutcomeFacts {
        #region Functor Rules

        [q("The identity map is a fixed point for Select() (first functor rule).")]
        public static bool Select01(int arg) {
            var m = Outcome<int>.η(arg);

            // fmap id  ==  id
            var left = m.Select(x => x);
            var right = m;

            return left.Equals(right);
        }

        [q("Select() preserves the composition operator (second functor rule).")]
        public static bool Select02(short arg0, int arg1, long arg2) {
            var m = Outcome<short>.η(arg0);
            Func<short, int> g = x => arg1 * x;
            Func<int, long> f = x => arg2 * x;

            // fmap (f . g)  ==  fmap f . fmap g
            var left = m.Select(val => f(g(val)));
            var right = m.Select(g).Select(f);

            return left.Equals(right);
        }

        #endregion

        #region Monad Rules

        [q("Of() is a left identity for Bind() (first monad rule).")]
        public static bool Of01(int arg0, float arg1) {
            Func<int, Outcome<float>> f = x => Outcome<float>.η(arg1 * x);

            // return a >>= k  ==  k a
            var left = Outcome<int>.η(arg0).Bind(f);
            var right = f(arg0);

            return left.Equals(right);
        }

        [q("Of() is a left identity for Compose() (first monad rule).")]
        public static bool Of02(int arg0, float arg1) {
            Func<int, Outcome<int>> of = Outcome<int>.η;
            Func<int, Outcome<float>> f = x => Outcome<float>.η(arg1 * x);

            // return >=> g  ==  g
            var left = of.Compose(f).Invoke(arg0);
            var right = f(arg0);

            return left.Equals(right);
        }

        [q("Of() is a right identity for Bind() (second monad rule).")]
        public static bool Of03(int arg0) {
            var m = Outcome<int>.η(arg0);

            // m >>= return  ==  m
            var left = m.Bind(Outcome<int>.η);
            var right = m;

            return left.Equals(right);
        }

        [q("Of() is a right identity for Compose() (second monad rule).")]
        public static bool Of04(int arg0, float arg1) {
            Func<int, Outcome<float>> f = x => Outcome<float>.η(arg1 * x);

            // f >=> return  ==  f
            var left = f.Compose(Outcome<float>.η).Invoke(arg0);
            var right = f(arg0);

            return left.Equals(right);
        }

        [q("Bind() is associative (third monad rule).")]
        public static bool Bind01(short arg0, int arg1, long arg2) {
            var m = Outcome<short>.η(arg0);

            Func<short, Outcome<int>> f = x => Outcome<int>.η(arg1 * x);
            Func<int, Outcome<long>> g = x => Outcome<long>.η(arg2 * x);

            // m >>= (\x -> f x >>= g)  ==  (m >>= f) >>= g
            var left = m.Bind(f).Bind(g);
            var right = m.Bind(val => f(val).Bind(g));

            return left.Equals(right);
        }

        [q("Compose() is associative (third monad rule).")]
        public static bool Compose01(short arg0, int arg1, long arg2, double arg3) {
            Func<short, Outcome<int>> f = x => Outcome<int>.η(arg1 * x);
            Func<int, Outcome<long>> g = x => Outcome<long>.η(arg2 * x);
            Func<long, Outcome<double>> h = x => Outcome<double>.η(arg3 * x);

            // f >=> (g >=> h)  ==  (f >=> g) >=> h
            var left = f.Compose(g.Compose(h)).Invoke(arg0);
            var right = f.Compose(g).Compose(h).Invoke(arg0);

            return left.Equals(right);
        }

        #endregion
    }

#endif
}

