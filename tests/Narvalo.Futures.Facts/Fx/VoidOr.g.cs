// Copyright (c) Narvalo.Org. All rights reserved. See LICENSE.txt in the project root for license information.

//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by a tool. Changes to this file may cause incorrect
// behavior and will be lost if the code is regenerated.
//
// Runtime Version: 4.0.30319.42000
// Microsoft.VisualStudio.TextTemplating: 14.0
// </auto-generated>
//------------------------------------------------------------------------------


namespace Narvalo.Fx
{
    using System;

    using Xunit;

    public static partial class VoidOrFacts
    {
        #region Linq Operators

        [Fact]
        public static void Select_ThrowsArgumentNullException_ForNullSelector()
        {
            // Arrange
            var source = VoidOr.FromError(1);
            Func<int, int> selector = null;

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => source.Select(selector));
        }


        [Fact]
        public static void Where_ThrowsArgumentNullException_ForNullPredicate()
        {
            // Arrange
            var source = VoidOr.FromError(1);
            Func<int, bool> predicate = null;

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => source.Where(predicate));
        }


        [Fact]
        public static void SelectMany_ThrowsArgumentNullException_ForNullValueSelector()
        {
            // Arrange
            var source = VoidOr.FromError(1);
            Func<int, VoidOr<int>> valueSelector = null;
            Func<int, int, int> resultSelector = (i, j) => i + j;

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => source.SelectMany(valueSelector, resultSelector));
        }

        [Fact]
        public static void SelectMany_ThrowsArgumentNullException_ForNullResultSelector()
        {
            // Arrange
            var source = VoidOr.FromError(1);
            var middle = VoidOr.FromError(2);
            Func<int, VoidOr<int>> valueSelector = _ => middle;
            Func<int, int, int> resultSelector = null;

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => source.SelectMany(valueSelector, resultSelector));
        }

        #endregion

        #region Monad Laws


        [Fact]
        public static void VoidOr_SatisfiesFirstMonoidLaw()
        {
            // Arrange
            var monad = VoidOr.FromError(1);

            // Act
            var left = VoidOr<int>.Void.OrElse(monad);
            var right = monad;

            // Assert
            Assert.True(left.Equals(right));
        }

        [Fact]
        public static void VoidOr_SatisfiesSecondMonoidLaw()
        {
            // Arrange
            var monad = VoidOr.FromError(1);

            // Act
            var left = monad.OrElse(VoidOr<int>.Void);
            var right = monad;

            // Assert
            Assert.True(left.Equals(right));
        }

        [Fact]
        public static void VoidOr_SatisfiesThirdMonoidLaw()
        {
            // Arrange
            var monadA = VoidOr.FromError(1);
            var monadB = VoidOr.FromError(2);
            var monadC = VoidOr.FromError(3);

            // Act
            var left = monadA.OrElse(monadB.OrElse(monadC));
            var right = monadA.OrElse(monadB).OrElse(monadC);

            // Assert
            Assert.True(left.Equals(right));
        }


        [Fact]
        public static void VoidOr_SatisfiesFirstMonadLaw()
        {
            // Arrange
            int value = 1;
            Func<int, VoidOr<long>> kun = _ => VoidOr.FromError((long)2 * _);

            // Act
            var left = VoidOr.FromError(value).Bind(kun);
            var right = kun(value);

            // Assert
            Assert.True(left.Equals(right));
        }

        [Fact]
        public static void VoidOr_SatisfiesSecondMonadLaw()
        {
            // Arrange
            Func<int, VoidOr<int>> create = _ => VoidOr.FromError(_);
            var monad = VoidOr.FromError(1);

            // Act
            var left = monad.Bind(create);
            var right = monad;

            // Assert
            Assert.True(left.Equals(right));
        }

        [Fact]
        public static void VoidOr_SatisfiesThirdMonadLaw()
        {
            // Arrange
            VoidOr<short> m = VoidOr.FromError((short)1);
            Func<short, VoidOr<int>> f = _ => VoidOr.FromError((int)3 * _);
            Func<int, VoidOr<long>> g = _ => VoidOr.FromError((long)2 * _);

            // Act
            var left = m.Bind(f).Bind(g);
            var right = m.Bind(_ => f(_).Bind(g));

            // Assert
            Assert.True(left.Equals(right));
        }


        [Fact]
        public static void VoidOr_SatisfiesMonadZeroRule()
        {
            // Arrange
            Func<int, VoidOr<long>> kun = _ => VoidOr.FromError((long)2 * _);

            // Act
            var left = VoidOr<int>.Void.Bind(kun);
            var right = VoidOr<long>.Void;

            // Assert
            Assert.True(left.Equals(right));
        }

        [Fact]
        public static void VoidOr_SatisfiesMonadMoreRule()
        {
            // Act
            var leftSome = VoidOr.FromError(1).Bind(_ => VoidOr<int>.Void);
            var leftNone = VoidOr<int>.Void.Bind(_ => VoidOr<int>.Void);
            var right = VoidOr<int>.Void;

            // Assert
            Assert.True(leftSome.Equals(right));
            Assert.True(leftNone.Equals(right));
        }


        [Fact]
        public static void VoidOr_SatisfiesMonadOrRule()
        {
            // Arrange
            var monad = VoidOr.FromError(2);

            // Act
            var leftSome = monad.OrElse(VoidOr.FromError(1));
            var leftNone = monad.OrElse(VoidOr<int>.Void);
            var right = monad;

            // Assert
            Assert.True(leftSome.Equals(right));
            Assert.True(leftNone.Equals(right));
        }

        [Fact]
        public static void VoidOr_DoesNotSatisfyRightZeroForPlus()
        {
            // Arrange
            var monad = VoidOr.FromError(2);

            // Act
            var leftSome = VoidOr.FromError(1).OrElse(monad);
            var leftNone = VoidOr<int>.Void.OrElse(monad);
            var right = monad;

            // Assert
            Assert.False(leftSome.Equals(right));   // NB: Fails here the "Unit is a right zero for Plus".
            Assert.True(leftNone.Equals(right));
        }


        #endregion
    } // End of VoidOr - T4: EmitFacts().
} // End of Narvalo.Fx.

