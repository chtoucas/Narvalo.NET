<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="chtoucas [at] narvalo [dot] org">
  <title>On Monads</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="assets/main.css">
  <link rel="stylesheet" href="styles/vs.css">
</head>
<body>
<header>
<h1 class="title">On Monads</h1>
<h2 class="author">chtoucas [at] narvalo [dot] org</h2>
</header>
<nav id="TOC">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#monoid">Monoid</a><ul>
<li><a href="#standard-extension-concat-aka-reduce">Standard Extension: Concat aka Reduce</a></li>
<li><a href="#weaker-forms-magma-and-semigroup">Weaker Forms: Magma and Semigroup</a></li>
<li><a href="#summary">Summary</a></li>
</ul></li>
<li><a href="#functor">Functor</a><ul>
<li><a href="#summary-1">Summary</a></li>
</ul></li>
<li><a href="#applicative-functor">Applicative Functor</a><ul>
<li><a href="#further-readings-2">Further readings</a></li>
</ul></li>
<li><a href="#monad">Monad</a><ul>
<li><a href="#extension-methods">Extension Methods</a></li>
<li><a href="#query-expression-syntax">Query Expression Syntax</a></li>
<li><a href="#computation-expressions">Computation Expressions</a></li>
</ul></li>
<li><a href="#functions-in-the-kleisli-category">Functions in the Kleisli Category</a></li>
<li><a href="#triad-monad-revisited">Triad: Monad Revisited</a><ul>
<li><a href="#from-triads-to-monads">From Triads to Monads</a></li>
<li><a href="#from-monads-to-triads">From Monads to Triads</a></li>
</ul></li>
<li><a href="#comonad">Comonad</a></li>
<li><a href="#richer-monads">Richer Monads</a><ul>
<li><a href="#monadplus">MonadPlus</a></li>
<li><a href="#monadplus-reform">MonadPlus Reform</a></li>
<li><a href="#monadzero">MonadZero</a></li>
<li><a href="#monadmore">MonadMore</a></li>
<li><a href="#monadplus-1">MonadPlus</a></li>
<li><a href="#monador">MonadOr</a></li>
<li><a href="#summary-2">Summary</a></li>
</ul></li>
<li><a href="#monads-in-the-.net-framework">Monads in the .NET Framework</a><ul>
<li><a href="#ienumerablet"><code>IEnumerable&lt;T&gt;</code></a></li>
<li><a href="#nullablet"><code>Nullable&lt;T&gt;</code></a></li>
<li><a href="#funct"><code>Func&lt;T&gt;</code></a></li>
<li><a href="#lazyt"><code>Lazy&lt;T&gt;</code></a></li>
<li><a href="#taskt"><code>Task&lt;T&gt;</code></a></li>
<li><a href="#maybet"><code>Maybe&lt;T&gt;</code></a></li>
<li><a href="#state">State</a></li>
<li><a href="#write">Write</a></li>
<li><a href="#reader">Reader</a></li>
<li><a href="#errort"><code>Error&lt;T&gt;</code></a></li>
</ul></li>
<li><a href="#an-haskell-to-c-dictionary">An Haskell to C# Dictionary</a><ul>
<li><a href="#monad-1">Monad</a></li>
<li><a href="#monadplus-2">MonadPlus</a></li>
<li><a href="#basic-monad-functions">Basic Monad functions</a></li>
<li><a href="#generalisations-of-list-functions">Generalisations of list functions</a></li>
<li><a href="#conditional-execution-of-monadic-expressions">Conditional execution of monadic expressions</a></li>
<li><a href="#monadic-lifting-operators">Monadic lifting operators</a></li>
<li><a href="#extras">Extras</a></li>
</ul></li>
<li><a href="#implementations">Implementations</a></li>
</ul>
</nav>
<p><strong>WARNING</strong>: These are my reading notes on the subject, this is NOT a tutorial.</p>
<h2 id="introduction">Introduction</h2>
<p>Monads have the undeserved reputation of being hard. It is certainly due to the fact that many people try to explain them using the jargon of category theory. Truth to be told, we don’t need to understand the theory behind to make good use of monads.</p>
<p>The C# type system is not rich enough to make general monadic constructions but it gives developers access to some powerful monadic concepts in a very friendly way. In fact, monad theory has clearly influenced the design of some core parts of the .NET framework; LINQ and the Reactive extensions being the most obvious proofs of that.</p>
<p><strong>A way to think about a monad is that it maps a value to a richer structure which satisfies a set of natural rules from which we can derive a very rich vocabulary.</strong></p>
<p>Whenever possible, we illustrate the discussion with analogies from the set of natural numbers, the boolean algebra, lists in the context of F# and LINQ in C#. Beware, these analogies are not always accurate (most of the time they ain’t), but they should give you a feeling of what’s going on.</p>
<p>We also provide examples from Haskell, but if you do not have any knowledge of it, feel free to skip them.</p>
<p>References:</p>
<ul>
<li>The first public discussion of monads in the context of .NET seems to be due to <a href="http://blogs.msdn.com/b/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx">Wes Dyer</a>,</li>
<li>A popular explanation of monads by <a href="http://ericlippert.com/category/monads/">Eric Lippert</a>,</li>
<li>A more abstract one by <a href="http://laser.inf.ethz.ch/2012/slides/Meijer/">Erik Meijer</a>.</li>
</ul>
<p>Before moving to monads, we explain two preliminary concepts: monoids and functors. They are not necessary to understand monads but they are sufficiently simple that I could not resist including them.</p>
<h2 id="monoid">Monoid</h2>
<p>In Haskell, one defines:</p>
<pre class="haskell"><code>-- Empty element.
mempty :: a
-- Append method.
mappend :: a -&gt; a -&gt; a

-- First law.
mappend mempty x = x
-- Second law.
mappend x mempty = x
-- Third law.
mappend x (mappend y z) = mappend (mappend x y) z</code></pre>
<p>A monoid has a unit element <em>Empty</em> and a closed binary operation <em>Append</em> which satisfy the <strong>monoid laws</strong>:</p>
<ol type="1">
<li><em>Empty</em> is a left identity for <em>Append</em>.</li>
<li><em>Empty</em> is a right identity for <em>Append</em>.</li>
<li><em>Append</em> is associative.</li>
</ol>
<p>Remarks: A closed binary operation is a method that maps two values of a given type to a value of the same type. We say that <em>Empty</em> is a neutral element for <em>Append</em>.</p>
<p>For natural numbers, <em>Empty</em> is <code>0</code> and <em>Append</em> is the addition <code>+</code>. For the boolean algebra, <em>Empty</em> is <code>False</code> and <em>Append</em> is <code>∨</code>, the logical disjunction OR. The rules should then be familiar to anyone:</p>
<ol type="1">
<li><code>0 + x = x</code> and <code>False ∨ P = P</code>.</li>
<li><code>x + 0 = x</code> and <code>P ∨ False = P</code>.</li>
<li><code>x + (y + z) = (x + y) + z</code> and <code>P ∨ (Q ∨ R) = (P ∨ Q) ∨ R</code>.</li>
</ol>
<h4 id="f-lists">F# Lists</h4>
<p><em>Empty</em> is the empty list <code>[]</code> and <em>Append</em> is <code>List.append</code>, but the concatenation operator <code>@</code> works too. The first law says that prepending an empty list to a list does not change the list:</p>
<pre class="fsharp"><code>// Result is [1; 2; 3].
let r = [] @ [1; 2; 3]</code></pre>
<p>The second law says that appending an empty list to a list does not change the list:</p>
<pre class="fsharp"><code>// Result is [1; 2; 3].
let r = [1; 2; 3] @ []</code></pre>
<p>The third law says that when concatenating several lists together, <strong>we don’t have to worry about operator precedence</strong>:</p>
<pre class="fsharp"><code>// On both sides, the result is [1; 2; 3; 4; 5; 6].
let lhs = [1; 2] @ ( [3; 4] @ [5; 6] )
let rhs = ( [1; 2] @ [3; 4] ) @ [5; 6]</code></pre>
<p>Indeed, on the LHS, we obtain <code>[1; 2] @ [3; 4; 5; 6]</code> <em>i.e.</em> <code>[1; 2; 3; 4; 5; 6]</code> and, on the RHS, we obtain <code>[1; 2; 3; 4] @ [5; 6]</code> <em>i.e.</em> <code>[1; 2; 3; 4; 5; 6]</code>.</p>
<h4 id="linq">LINQ</h4>
<p><em>Empty</em> is the empty sequence <code>Enumerable.Empty&lt;T&gt;()</code> and <em>Append</em> is the <code>Concat</code> method. If <code>q</code>, <code>r</code> and <code>s</code> are of type <code>IEnumerable&lt;T&gt;</code>, the monoid laws say:</p>
<pre class="csharp"><code>var empty = Enumerable.Empty&lt;T&gt;();

// First law. Result is q.
var r1 = empty.Concat(q);

// Second law. Result is q.
var r2 = q.Concat(empty);

// Third law. Both sides are equal.
var lhs = q.Concat(r.Concat(s));
var rhs = q.Concat(r).Concat(s);</code></pre>
<h4 id="pseudocode-in-c">Pseudocode in C#</h4>
<p>It is just a matter of generalizing the LINQ definitions to an hypothetical <code>Monoid</code> class:</p>
<pre class="csharp"><code>// Skeleton definition of a monoid.
public class Monoid {
    // Empty property.
    public static Monoid Empty {
        get { throw new NotImplementedException(); }
    }

    // Append method.
    public Monoid Append(Monoid other) {
        throw new NotImplementedException();
    }
}</code></pre>
<p>If <code>m</code>, <code>m1</code>, <code>m2</code> and <code>m3</code> are of type <code>Monoid</code>, they must follow the following rules:</p>
<pre class="csharp"><code>// First law. Result must be equal to m.
var r1 = Monoid.Empty.Append(m);

// Second law. Result must be equal to m.
var r2 = m.Append(Monoid.Empty);

// Third law. Both sides must be equal.
var lhs = m1.Append(m2.Append(m3));
var rhs = m1.Append(m2).Append(m3);</code></pre>
<p>There ares sevaral instances of monoids in C#. For instance,</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;"><em>Empty</em></th>
<th style="text-align: left;"><em>Append</em></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;"><code>+</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>int</code></td>
<td style="text-align: left;"><code>1</code></td>
<td style="text-align: left;"><code>*</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>bool</code></td>
<td style="text-align: left;"><code>false</code></td>
<td style="text-align: left;"><code>||</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>bool</code></td>
<td style="text-align: left;"><code>true</code></td>
<td style="text-align: left;"><code>&amp;&amp;</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>string</code></td>
<td style="text-align: left;"><code>String.Empty</code></td>
<td style="text-align: left;"><code>+</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>IEnumerable&lt;T&gt;</code></td>
<td style="text-align: left;"><code>Enumerable.Empty&lt;T&gt;()</code></td>
<td style="text-align: left;"><code>Enumerable.Concat</code></td>
</tr>
</tbody>
</table>
<h3 id="standard-extension-concat-aka-reduce">Standard Extension: Concat aka Reduce</h3>
<p>Haskell also includes an operation <code>mconcat</code> which derives from <code>mempty</code> and <code>mappend</code>. <em>Concat</em> is a generalization of <em>Append</em> to an arbitrary number of lists.</p>
<pre class="haskell"><code>-- Concat method
mconcat :: [a] -&gt; a
mconcat = foldr mappend mempty</code></pre>
<p>For F# lists, <em>Concat</em> is <code>List.concat</code>. For instance,</p>
<pre class="fsharp"><code>// Result is [1; 2; 3; 4; 5; 6]
let r = List.concat [ [1; 2]; [3; 4]; [5; 6] ]</code></pre>
<p>For LINQ,</p>
<pre class="csharp"><code>public static IEnumerable&lt;T&gt; Concat&lt;T&gt;(this IEnumerable&lt;IEnumerable&lt;T&gt;&gt; @this) {
    return @this.Aggregate(Enumerable.Empty&lt;T&gt;(), (seq1, seq2) =&gt; seq1.Concat(seq2));
}

// Using the query expression syntax, this is even clearer.
public static IEnumerable&lt;T&gt; Concat&lt;T&gt;(this IEnumerable&lt;IEnumerable&lt;T&gt;&gt; @this) {
    return from list in @this
           from item in list
           select item;
}</code></pre>
<p>and for our hypothetical monoid class, this translates to:</p>
<pre class="csharp"><code>public static Monoid Reduce(this IEnumerable&lt;Monoid&gt; @this) {
    return @this.Aggregate(Monoid.Empty, (m1, m2) =&gt; m1.Append(m2));
}</code></pre>
<p><em>i.e.</em> we can <strong>always reduce a list of monoid values to a single monoid value</strong>. So, if <code>Concat</code> may be a very natural name for lists, for more general monoids, <code>Reduce</code> is a much better fit, closer to its real meaning.</p>
<h3 id="weaker-forms-magma-and-semigroup">Weaker Forms: Magma and Semigroup</h3>
<p>A <strong>magma</strong> only defines a closed binary operation <em>Append</em>. The set of binary trees for a given type is an example of a (free) magma.</p>
<p>A <strong>semigroup</strong> is a magma for which <em>Append</em> is associative, <em>i.e.</em> it is almost a monoid but without the requirement of a neutral element.</p>
<pre class="csharp"><code>public class Semigroup {
    // Append method.
    public Semigroup Append(Semigroup other) {
        throw new NotImplementedException();
    }
}</code></pre>
<p>If <code>a</code>, <code>b</code> and <code>b</code> are of type <code>Semigroup</code>, they must follow the following rule:</p>
<pre class="csharp"><code>// Both sides must be equal.
var lhs = a.Append(b.Append(c));
var rhs = a.Append(b).Append(c);</code></pre>
<p>Previously, we defined a <em>Concat</em> method whenever we had a monoid but notice that it required the existence of a neutral element. Even if semigroups do not have this buddy, with some restrictions, we can achieve something similar:</p>
<pre class="csharp"><code>public static class Semigroup {
    // Reduce a *non-empty* sequence using Append.
    public static Semigroup Sum(this IEnumerable&lt;Semigroup&gt; @this) {
        using (var iter = @this.GetEnumerator()) {
            if (!iter.MoveNext()) {
                throw new InvalidOperationException(&quot;Source sequence is empty.&quot;);
            }

            Semigroup retval = iter.Current;

            while (iter.MoveNext()) {
                retval = retval.Append(iter.Current);
            }

            return retval;
        }
    }
}</code></pre>
<p>If the semigroup is also a monoid, <code>Concat</code> with non-empty sequences is equivalent to <code>Sum</code>.</p>
<h3 id="summary">Summary</h3>
<p>A monoid defines an associative operation <em>Append</em> and a neutral element <em>Empty</em> for <em>Append</em>.</p>
<p>Associativity means that we can divide a sequence of operations into smaller steps without having to worry about operator precedence.</p>
<p>The existence of a neutral element means that we can always reduce a sequence of values to a single value.</p>
<h4 id="further-readings">Further readings</h4>
<ul>
<li>Haskell, <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Monoid.html">Data.Monoid</a> and <a href="https://hackage.haskell.org/package/semigroups-0.8/docs/Data-Semigroup.html">Data.Semigroup</a>.</li>
<li>F# for fun and profit, <a href="http://fsharpforfunandprofit.com/posts/monoids-without-tears/">Monoids without tears</a>.</li>
</ul>
<h2 id="functor">Functor</h2>
<p>In Haskell, one defines:</p>
<pre class="haskell"><code>-- Map method.
fmap :: (a -&gt; b) -&gt; f a -&gt; f b

-- First law.
fmap id == id
-- Second law.
fmap (f . g) == fmap f . fmap g</code></pre>
<p>A functor has a <em>Map</em> operation that satisfy the <strong>functor laws</strong>:</p>
<ol type="1">
<li><em>Map</em> preserves the identity map,</li>
<li><em>Map</em> preserves the composition operator.</li>
</ol>
<h4 id="f-lists-1">F# Lists</h4>
<p><em>Map</em> is <code>List.map</code>. The first law says that iterating over list and returning the unmodified items is the same as iterating over the list:</p>
<pre class="fsharp"><code>// Result is [1; 2].
let r = [1; 2] |&gt; List.map id</code></pre>
<p>This is obvious, applying <code>id</code> to each element we get <code>[id(1); id(2)]</code> <em>i.e.</em> <code>[1; 2]</code>. The second law says that iterating over a list and applying <code>g</code> then <code>f</code> to each item is the same as iterating, applying <code>g</code>, iterating again and applying <code>f</code>. For instance,</p>
<pre class="fsharp"><code>let f x = -x
let g x = x * x
let h = f &lt;&lt; g

// On both sides, the result is [-1; -4].
let lhs = List.map h &lt;| [1; 2]
let rhs = List.map f &lt;&lt; List.map g &lt;| [1; 2]</code></pre>
<p>Indeed, on the LHS, we obtain <code>[h(1); h(2)]</code> <em>i.e.</em> <code>[-1; -4]</code> and, on the RHS, we obtain <code>[g(1); g(2)]</code> <em>i.e.</em> <code>[1; 4]</code> then <code>[f(1); f(4))]</code> <em>i.e.</em> <code>[-1; -4]</code>.</p>
<h4 id="linq-1">LINQ</h4>
<p><em>Map</em> is the <code>Select</code> method:</p>
<pre class="csharp"><code>// First law. In both cases, result is q.
var r1 = q.Select(_ =&gt; _);
// Using the query expression syntax.
var r2 = from _ in q select _;

// Second law. Both sides are equal.
var lhs1 = q.Select(_ =&gt; f(g(_)));
var rhs1 = q.Select(g).Select(f);
// Using the query expression syntax.
var lhs2 = from _ in q select f(g(_));
var rhs2 = from item
               in (from _ in q select g(_))
           select f(item);</code></pre>
<h4 id="pseudocode-in-c-1">Pseudocode in C#</h4>
<pre class="csharp"><code>// Skeleton definition of a functor.
public class Functor&lt;T&gt; {
    // Map method.
    public Functor&lt;TResult&gt; Map&lt;TResult&gt;(Func&lt;T, TResult&gt; selector) {
        throw new NotImplementedException();
    }
}

// Functor laws.
public static class FunctorLaws {
    public static void FirstLaw&lt;T&gt;(Functor&lt;T&gt; m) {
        // First law. Result must be equal to m.
        var r = m.Map(_ =&gt; _);
    }

    public static void SecondLaw&lt;T1, T2, T3&gt;(Functor&lt;T1&gt; m, Func&lt;T2, T3&gt; f, Func&lt;T1, T2&gt; g) {
        // Second law. Both sides must be equal.
        var lhs = m.Map(_ =&gt; f(g(_)));
        var rhs = m.Map(g).Map(f);
    }
}</code></pre>
<h3 id="summary-1">Summary</h3>
<h4 id="further-readings-1">Further readings</h4>
<ul>
<li>Haskell, <a href="https://hackage.haskell.org/package/base-4.7.0.1/docs/Data-Functor.html">Data.Functor</a></li>
</ul>
<h2 id="applicative-functor">Applicative Functor</h2>
<p>In Haskell, one defines:</p>
<pre class="haskell"><code>-- Pure method.
pure :: a -&gt; f a
-- Gather method.
(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b

-- First law.
pure id &lt;*&gt; v = v
-- Second law.
pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)
-- Third law.
pure f &lt;*&gt; pure x = pure (f x)
-- Fourth law.
u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</code></pre>
<p>For F# lists,</p>
<pre class="fsharp"><code>// Pure method.
let pure x = [x]</code></pre>
<pre class="fsharp"><code>let f = id
let g x = 2 * x
let h x = 3 * x</code></pre>
<p>For LINQ,</p>
<pre class="csharp"><code>public static class Sequence {
    // Create a list of one element from a value.
    public static IEnumerable&lt;T&gt; Pure&lt;T&gt;(T value) {
        yield return value
    }

    // For instance, with
    //  f: x -&gt; x
    //  g: x -&gt; 2 * x
    //  h: x -&gt; 3 * x
    // lifting [1; 2] with [f; g; h] gives:
    //  [1; 2] -&gt; [f(1); f(2); g(1); g(2); h(1); h(2)]
    //              = [1; 2; 2; 4; 3; 6]
    public static IEnumerable&lt;TResult&gt; Gather&lt;TSource, TResult&gt;(
        this IEnumerable&lt;TSource&gt; @this,
        IEnumerable&lt;Func&lt;T, TResult&gt;&gt; funs)
    {
        foreach (var fun in funs) {
            foreach (var item in @this) {
                yield return funs(item);
            }
        }
    }
}</code></pre>
<p>In C#,</p>
<pre class="csharp"><code>// Skeleton definition of an applicative functor.
public static class Applicative&lt;T&gt; {
    // Gather method.
    public Applicative&lt;TResult&gt; Gather&lt;TResult&gt;(Applicative&lt;Func&lt;T, TResult&gt;&gt; funs) {
        throw new NotImplementedException();
    }
}

public static class Applicative {
    // Pure method.
    public static Applicative&lt;T&gt; Pure&lt;T&gt;(T value) {
        throw new NotImplementedException();
    }
}</code></pre>
<h3 id="further-readings-2">Further readings</h3>
<ul>
<li>Haskell, <a href="https://hackage.haskell.org/package/base-4.5.0.0/docs/Control-Applicative.html">Control.Applicative</a></li>
</ul>
<h2 id="monad">Monad</h2>
<p>References:</p>
<ul>
<li><a href="http://www.haskell.org/onlinereport/monad.html">The Haskell 98 Report</a></li>
<li><a href="https://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html">Control.Monad</a></li>
</ul>
<p>In Haskell:</p>
<pre class="haskell"><code>-- Bind method.
(&gt;&gt;=) :: forall a b. m a -&gt; (a -&gt; m b) -&gt; m b
-- Return method.
return :: a -&gt; m a

-- First law: Return is a left identity for Bind.
return a &gt;&gt;= f == f a
-- Second law: Return is a right identity for Bind.
m &gt;&gt;= return == m
-- Third law: Bind is associative.
m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g) == (m &gt;&gt;= f) &gt;&gt;= g</code></pre>
<p>A monad has a unit element <em>Return</em> and a <em>Bind</em> operation that satisfy the <strong>monad laws</strong>:</p>
<ul>
<li><em>Return</em> is the identity for <em>Bind</em>.</li>
<li><em>Bind</em> is associative.</li>
</ul>
<p>Since <em>Bind</em> is not necessary a commutative operation, the first law really means two things:</p>
<ul>
<li><em>Return</em> is a left identity for <em>Bind</em>,</li>
<li><em>Return</em> is a right identity for <em>Bind</em>.</li>
</ul>
<p>In arithmetic, <code>Return</code> would be <code>1</code> and <code>Bind</code> would be <code>*</code>. For the boolean algebra, <code>Return</code> would be <code>True</code> and <code>Append</code> would be <code>∧</code>, the logical conjunction AND. The rules should then be familiar to anyone:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Rule</th>
<th style="text-align: left;">Translation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Left identity</td>
<td style="text-align: left;"><code>1 * x = x</code> and <code>True ∧ P = P</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Right identity</td>
<td style="text-align: left;"><code>x * 1 = x</code> and <code>P ∧ True = P</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Associativity</td>
<td style="text-align: left;"><code>x * (y * z) = (x * y) * z</code> and <code>P ∧ (Q ∧ R) = (P ∧ Q) ∧ R</code></td>
</tr>
</tbody>
</table>
<p>For LINQ,</p>
<pre class="csharp"><code>public static class Sequence {
    // Map each element of a list to a list, resulting in a list of lists
    // which is then flattened.
    public static IEnumerable&lt;TResult&gt; Bind&lt;TSource, TResult&gt;(
        this IEnumerable&lt;TSource&gt; @this,
        Func&lt;TSource, IEnumerable&lt;TResult&gt;&gt; fun)
    {
        return from _ in @this
               from item in fun(_)
               select item;
    }

    // Create a list of one element from a value.
    public static IEnumerable&lt;T&gt; Single&lt;T&gt;(T value) {
        yield return value;
    }
}

// First law: Iterating over a list of one element and creating a list by applying f
// to this unique value is the same as creating a list by applying f to the unique element.
// For instance, with f: x -&gt; [x; 2], on the LHS, we have:
//  1 -&gt; [1]
//    -&gt; [f(1)] = [[1; 2]]          (apply f)
//    -&gt; [1; 2]                     (flatten)
// and, on the RHS:
//  f(1) = [1; 2]
Sequence.Single(value).Bind(f) == f(value);
// or using the query expression syntax:
from _ in Sequence.Single(value) from item in f(_) select item
    == f(value);

// Second law: Iterating over a list and for each element returning a list containing only
// this element is the same as iterating over the list.
// For instance,
//  [1; 2; 3] -&gt; [[1]; [2]; [3]]    (apply Single)
//            -&gt; [1; 2; 3]          (flatten)
q.Bind(Sequence.Single) == q;
// or using the query expression syntax:
from _ in q from item in Sequence.Single(_) select item
    == q;

// Third law: Bind is associative.
// For instance, with
//  f: x -&gt; [x; 1]
//  g: x -&gt; [x; 2]
// we have on the LHS:
//  [3; 4] -&gt; [f(3); f(4)]                              (apply f)
//              = [[3; 1]; [4; 1]]
//         -&gt; [[g(3); g(1)]; [g(4); g(1)]]              (apply g)
//              = [[[3; 2]; [1; 2]]; [[4; 2]; [1; 2]]]
//         -&gt; [[3; 2; 1; 2]; [4; 2; 1; 2]]              (flatten the inner seq)
//         -&gt; [3; 2; 1; 2; 4; 2; 1; 2]                  (flatten the outer seq)
// and on the RHS:
//  [3; 4] -&gt; [f(3); f(4)]                              (apply f)
//              = [[3; 1]; [4; 1]]
//         -&gt; [3; 1; 4; 1]                              (flatten)
//         -&gt; [g(3); g(1); g(4); g(1))]                 (apply g)
//              = [[3; 2]; [1; 2]; [4; 2]; [1; 2]]
//         -&gt; [3; 2; 1; 2; 4; 2; 1; 2]                  (flatten)
q.Bind(_ =&gt; f(_).Bind(g)) == q.Bind(f).Bind(g);
// or using the query expression syntax:
from _ in q
from item
    in (from outer in f(_) from inner in g(outer) select inner)
select item
    == from _ in (from outer in q from inner in f(outer) select inner)
       from item in g(_)
       select item;</code></pre>
<p>In C#:</p>
<pre class="csharp"><code>// Skeleton definition of a monad.
public class Monad&lt;T&gt; {
    // Bind method.
    public Monad&lt;TResult&gt; Bind&lt;TResult&gt;(Func&lt;T, Monad&lt;TResult&gt;&gt; fun) {
        throw new NotImplementedException();
    }
}

public static class Monad {
    // Return method.
    public static Monad&lt;T&gt; Return&lt;T&gt;(T value) {
        throw new NotImplementedException();
    }
}

// Monad laws.
public static class MonadLaws {
    // First law: Return is a left identity for Bind.
    public static void FirstLaw&lt;X, Y&gt;(Func&lt;X, Monad&lt;Y&gt;&gt; f, X value) {
        Monad.Return(value).Bind(f) == f(value);
    }

    // Second law: Return is a right identity for Bind.
    public static void SecondLaw&lt;X&gt;(Monad&lt;X&gt; m) {
        m.Bind(Monad.Return) == m;
    }

    // Third law: Bind is associative.
    public static void ThirdLaw&lt;X, Y, Z&gt;(Monad&lt;X&gt; m, Func&lt;X, Monad&lt;Y&gt;&gt; f, Func&lt;Y, Monad&lt;Z&gt;&gt; g) {
        m.Bind(_ =&gt; f(_).Bind(g)) == m.Bind(f).Bind(g);
    }
}</code></pre>
<p>Haskell also provides a <code>fail</code> method which is not part of the standard definition of a monad. It is mostly used for pattern matching failure, something we do not have in .NET.</p>
<h3 id="extension-methods">Extension Methods</h3>
<h3 id="query-expression-syntax">Query Expression Syntax</h3>
<h3 id="computation-expressions">Computation Expressions</h3>
<h2 id="functions-in-the-kleisli-category">Functions in the Kleisli Category</h2>
<p>A function in the Kleisli category is simply a function that maps a value to a monad. Of course, functions can be invoked or composed with another function.</p>
<p>In Haskell:</p>
<pre class="haskell"><code>-- Invoke method.
(=&lt;&lt;) :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
f =&lt;&lt; x = x &gt;&gt;= f

-- Compose method.
(&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c
f &gt;=&gt; g = \x -&gt; f x &gt;&gt;= g

-- ComposeBack method.
(&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
(&lt;=&lt;) = flip (&gt;=&gt;)</code></pre>
<p>In C#:</p>
<pre class="csharp"><code>public delegate Monad&lt;TResult&gt; Kunc&lt;in TSource, TResult&gt;(TSource arg);

public static partial class KuncExtensions
{
    // Invoke method.
    public static Monad&lt;TResult&gt; Invoke&lt;TSource, TResult&gt;(
        this Kunc&lt;TSource, TResult&gt; @this,
        Monad&lt;TSource&gt; monad)
    {
        return monad.Bind(@this);
    }

    // Compose method.
    public static Kunc&lt;TSource, TResult&gt; Compose&lt;TSource, TMiddle, TResult&gt;(
        this Kunc&lt;TSource, TMiddle&gt; @this,
        Kunc&lt;TMiddle, TResult&gt; kun)
    {
        return _ =&gt; @this.Invoke(_).Bind(kun);
    }

    // ComposeBack method.
    public static Kunc&lt;TSource, TResult&gt; ComposeBack&lt;TSource, TMiddle, TResult&gt;(
        this Kunc&lt;TMiddle, TResult&gt; @this,
        Kunc&lt;TSource, TMiddle&gt; kun)
    {
        return _ =&gt; kun.Invoke(_).Bind(@this);
    }
}</code></pre>
<p><code>Invoke</code> being just <code>Bind</code> with the arguments flipped, we can then rewrite the monad laws in a more readable fashion.</p>
<p>In Haskell:</p>
<pre class="haskell"><code>-- First law: Return is a left identity for Compose.
return &gt;=&gt; g ≡ g
-- Second law: Return is a right identity for Compose.
f &gt;=&gt; return ≡ f
-- Third law: Compose is associative.
(f &gt;=&gt; g) &gt;=&gt; h ≡ f &gt;=&gt; (g &gt;=&gt; h)</code></pre>
<p>In C#:</p>
<pre class="csharp"><code>public static class MonadLaws {
    // First law: Return is a left identity for Compose.
    public static void FirstLaw&lt;X, Y&gt;(Kunc&lt;X, Y&gt; g, X value) {
        Kunc&lt;X, X&gt; kReturn = Monad.Return;

        kReturn.Compose(g).Invoke(value) == g(value);
    }

    // Second law: Return is a right identity for Compose.
    public static void SecondLaw&lt;X, Y&gt;(Kunc&lt;X, Y&gt; f, X value) {
        f.Compose(Monad.Return).Invoke(value) == f(value);
    }

    // Third law: Compose is associative.
    public static void ThirdLaw&lt;X, Y, Z, T&gt;(Kunc&lt;X, Y&gt; f, Kunc&lt;Y, Z&gt; g, Kunc&lt;Z, T&gt; h, X value) {
        (f.Compose(g)).Compose(h).Invoke(value) == f.Compose(g.Compose(h)).Invoke(value);
    }
}</code></pre>
<h2 id="triad-monad-revisited">Triad: Monad Revisited</h2>
<p>If one wishes to stay closer to the definition of monads from category theory, a Monad is equivalently defined by a unit element <code>Return</code> and two operations <code>Map</code> and <code>Multiply</code> where <code>Map</code> must satisfy the functor laws.</p>
<p>In Haskell:</p>
<pre class="haskell"><code>-- Return method.
return :: a -&gt; m a
-- Map method.
fmap :: (a -&gt; b) -&gt; f a -&gt; f b
-- Multiply method.
join :: Monad m =&gt; m (m a) -&gt; m a</code></pre>
<p>In C#:</p>
<pre class="csharp"><code>public class Monad&lt;T&gt; {
    // Map method.
    public Monad&lt;TResult&gt; Map&lt;TResult&gt;(Func&lt;T, TResult&gt; selector) {
        throw new NotImplementedException();
    }
}

public static class Monad {
    // Return method.
    public static Monad&lt;T&gt; Return&lt;T&gt;(T value) {
        throw new NotImplementedException();
    }

    // Multiply method.
    public static Monad&lt;T&gt; Multiply&lt;T&gt;(Monad&lt;Monad&lt;T&gt;&gt; square) {
        throw new NotImplementedException();
    }
}</code></pre>
<h3 id="from-triads-to-monads">From Triads to Monads</h3>
<p>In Haskell:</p>
<pre class="haskell"><code>-- Bind defined via Multiply and Map.
m &gt;&gt;= g = join (fmap g m)</code></pre>
<p>In C#:</p>
<pre class="csharp"><code>public class Monad&lt;T&gt; {
    // Bind defined via Multiply and Map.
    public Monad&lt;TResult&gt; Bind&lt;TResult&gt;(Func&lt;T, Monad&lt;TResult&gt;&gt; kun) {
        return Monad&lt;TResult&gt;.Multiply(Map(kun));
    }
}</code></pre>
<h3 id="from-monads-to-triads">From Monads to Triads</h3>
<p>In Haskell:</p>
<pre class="haskell"><code>-- Map defined via Return and Bind.
fmap f x = x &gt;&gt;= (return . f)
-- Multiply defined via Bind.
join x = x &gt;&gt;= id</code></pre>
<p>In C#:</p>
<pre class="csharp"><code>public class Monad&lt;T&gt; {
    // Map defined via Return and Bind.
    public Monad&lt;TResult&gt; Map&lt;TResult&gt;(Func&lt;T, TResult&gt; selector) {
        return Bind(_ =&gt; Monad&lt;TResult&gt;.Return(selector(_)));
    }
}

public static class Monad {
    // Multiply defined via Bind.
    public static Monad&lt;T&gt; Multiply(Monad&lt;Monad&lt;T&gt;&gt; square) {
        return square.Bind(_ =&gt; _);
    }
}</code></pre>
<p>The first functor law can be deduced from the above definition of <code>Map</code> and the second monad law:</p>
<pre class="haskell"><code>fmap id x = x &gt;&gt;= (return . id) = x &gt;&gt;= return = x</code></pre>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Signature</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Then</code> defined by <code>Bind</code></td>
<td style="text-align: left;"><code>m &gt;&gt; n = m &gt;&gt;= \_ -&gt; n</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Signature</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Then</code> Associativity</td>
<td style="text-align: left;"><code>(m &gt;&gt; n) &gt;&gt; o = m &gt;&gt; (n &gt;&gt; o)</code></td>
</tr>
</tbody>
</table>
<h2 id="comonad">Comonad</h2>
<p>There are two equivalent ways to define a Comonad:</p>
<ul>
<li><code>Counit</code>, <code>Cobind</code></li>
<li><code>Counit</code>, <code>Map</code>, <code>Comultiply</code></li>
</ul>
<h2 id="richer-monads">Richer Monads</h2>
<p>References:</p>
<ul>
<li><a href="http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal">MonadPlus Reform</a></li>
</ul>
<p>We follow (mostly) the proposed new terminology from the MonadPlus Reform.</p>
<h3 id="monadplus">MonadPlus</h3>
<h3 id="monadplus-reform">MonadPlus Reform</h3>
<h3 id="monadzero">MonadZero</h3>
<p>A MonadZero is a monad with a left zero for <code>Bind</code>.</p>
<h3 id="monadmore">MonadMore</h3>
<p>A MonadMore is a monad which is also a monoid and for which <code>Zero</code> is a zero for <code>Bind</code>. This is what Haskell calls a MonadPlus.</p>
<h3 id="monadplus-1">MonadPlus</h3>
<p>A MonadPlus is a monad which is also a monoid and for which <code>Bind</code> is right distributive over <code>Plus</code>.</p>
<p>REVIEW: Haskell uses the term left distributive. Am I missing something?</p>
<h3 id="monador">MonadOr</h3>
<p>A MonadOr is a monad which is also a monoid and for which <code>Unit</code> is a left zero for <code>Plus</code>. Here, we prefer to use <code>OrElse</code> instead of <code>Plus</code> for the monoid composition operation.</p>
<h3 id="summary-2">Summary</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Haskell</th>
<th style="text-align: left;">C#</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><em>Empty</em></td>
<td style="text-align: left;"><code>mzero</code></td>
<td style="text-align: left;"><code>Empty</code>, <code>Zero</code>, <code>None</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>Append</em></td>
<td style="text-align: left;"><code>mappend</code>, <code>mplus</code></td>
<td style="text-align: left;"><code>Append</code>, <code>Plus</code>, <code>OrElse</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>Flatten</em></td>
<td style="text-align: left;"><code>mconcat</code></td>
<td style="text-align: left;"><code>Flatten</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Signature</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">MonadZero Left zero</td>
<td style="text-align: left;"><code>mzero &gt;&gt;= f = mzero</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">MonadMore Right zero</td>
<td style="text-align: left;"><code>v &gt;&gt; mzero = mzero</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">(TODO)</td>
<td style="text-align: left;"><code>m &gt;&gt;= (\x -&gt; mzero) = mzero</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">MonadPlus Right distributivity</td>
<td style="text-align: left;"><code>mplus a b &gt;&gt;= f = mplus (a &gt;&gt;= f) (b &gt;&gt;= f)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Left distributivity</td>
<td style="text-align: left;">(TODO)</td>
</tr>
<tr class="even">
<td style="text-align: left;">MonadOr Left zero</td>
<td style="text-align: left;"><code>morelse (return a) b ≡ return a</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Right zero</td>
<td style="text-align: left;"><code>morelse a (return b) ≡ return b</code></td>
</tr>
</tbody>
</table>
<p>In arithmetic, <code>Empty</code> would be <code>0</code> and <code>Append</code> would be <code>+</code>. For the boolean algebra, <code>Empty</code> would be <code>False</code> and <code>Append</code> would be <code>∨</code>, the logical disjunction OR. The rules should then be familiar to anyone:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Rule</th>
<th style="text-align: left;">Translation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Left identity</td>
<td style="text-align: left;"><code>0 + x = x</code> and <code>False ∨ P = P</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Right identity</td>
<td style="text-align: left;"><code>x + 0 = x</code> and <code>P ∨ False = P</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Associativity</td>
<td style="text-align: left;"><code>x + (y + z) = (x + y) + z</code> and <code>P ∨ (Q ∨ R) = (P ∨ Q) ∨ R</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Signature</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">MonadZero Left zero</td>
<td style="text-align: left;"><code>0 * x = 0</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">MonadMore Right zero</td>
<td style="text-align: left;"><code>x * 0 = 0</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">MonadPlus Right distributivity</td>
<td style="text-align: left;"><code>(x + y) * z = x * z + x * z</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Left distributivity</td>
<td style="text-align: left;"><code>x * (y + z) = x * y + x * z</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">MonadOr Left zero</td>
<td style="text-align: left;">(TODO)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Right zero</td>
<td style="text-align: left;">(TODO)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Description</th>
<th style="text-align: left;">Signature</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">MonadZero Left zero</td>
<td style="text-align: left;"><code>False ∧ P = False</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">MonadMore Right zero</td>
<td style="text-align: left;"><code>P ∧ False = False</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">MonadPlus Right distributivity</td>
<td style="text-align: left;">(not available)</td>
</tr>
<tr class="even">
<td style="text-align: left;">Left distributivity</td>
<td style="text-align: left;"><code>P ∧ (Q ∨ R) = (P ∧ Q) ∨ (P ∧ R)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">MonadOr Left zero</td>
<td style="text-align: left;"><code>True ∨ P = True</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Right zero</td>
<td style="text-align: left;"><code>P ∨ True = True</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Monoid</td>
<td style="text-align: left;">(Plus, Zero) + Monoid Laws</td>
</tr>
<tr class="even">
<td style="text-align: left;">Monad</td>
<td style="text-align: left;">(Bind, Unit) + Monad Laws</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Comonad</td>
<td style="text-align: left;">(Cobind, Counit) + Comonad Laws</td>
</tr>
<tr class="even">
<td style="text-align: left;">MonadZero</td>
<td style="text-align: left;">(Monad, Zero) + Zero = left zero for Bind</td>
</tr>
<tr class="odd">
<td style="text-align: left;">MonadMore</td>
<td style="text-align: left;">Monad + Monoid + Zero = zero for Bind</td>
</tr>
<tr class="even">
<td style="text-align: left;">MonadPlus</td>
<td style="text-align: left;">Monad + Monoid + Right distributivity</td>
</tr>
<tr class="odd">
<td style="text-align: left;">MonadOr</td>
<td style="text-align: left;">Monad + Monoid + Unit = left zero for Plus</td>
</tr>
</tbody>
</table>
<h2 id="monads-in-the-.net-framework">Monads in the .NET Framework</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Class</th>
<th style="text-align: left;">Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>IEnumerable&lt;T&gt;</code></td>
<td style="text-align: left;">MonadZero, MonadPlus (?)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Nullable&lt;T&gt;</code></td>
<td style="text-align: left;">MonadMore, MonadOr (?)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Func&lt;T&gt;</code></td>
<td style="text-align: left;">(TODO)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Lazy&lt;T&gt;</code></td>
<td style="text-align: left;">Monad, Comonad (?)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Task&lt;T&gt;</code></td>
<td style="text-align: left;">Monad, Comonad (?)</td>
</tr>
</tbody>
</table>
<p>Sometimes we choose a more appropriate name than the default one.</p>
<p>We also prefer to use the name expected by the Query Expression Pattern (QEP). The immediate benefit is that we can use the query expression syntax (from, select, where). This is similar to the do syntaxic sugar of Haskell.</p>
<p>Monoid</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Haskell</th>
<th style="text-align: left;">Terminology used here</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Zero</code></td>
<td style="text-align: left;"><code>mzero</code></td>
<td style="text-align: left;"><code>Zero</code> or <code>None</code>, <code>Empty</code>, <code>Failure</code>,…</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Plus</code></td>
<td style="text-align: left;"><code>mplus</code></td>
<td style="text-align: left;"><code>Plus</code> or <code>OrElse</code>,…</td>
</tr>
</tbody>
</table>
<p>Monad</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Haskell</th>
<th style="text-align: left;">Terminology used here</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Unit</code> (<code>η</code>)</td>
<td style="text-align: left;"><code>return</code></td>
<td style="text-align: left;"><code>Return</code> or <code>Create</code>, <code>Success</code>,…</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Bind</code></td>
<td style="text-align: left;"><code>&gt;&gt;=</code></td>
<td style="text-align: left;"><code>Bind</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Map</code></td>
<td style="text-align: left;"><code>fmap</code> or <code>liftM</code></td>
<td style="text-align: left;"><code>Map</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Multiply</code> (<code>μ</code>)</td>
<td style="text-align: left;"><code>join</code></td>
<td style="text-align: left;"><code>Flatten</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Then</code></td>
<td style="text-align: left;"><code>&gt;&gt;</code></td>
<td style="text-align: left;"><code>Then</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">(TODO)</td>
<td style="text-align: left;"><code>fail</code></td>
<td style="text-align: left;">(TODO)</td>
</tr>
</tbody>
</table>
<p>Comonad</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Haskell</th>
<th style="text-align: left;">Terminology used here</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Counit</code> (<code>ε</code>)</td>
<td style="text-align: left;"><code>extract</code></td>
<td style="text-align: left;"><code>Extract</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Cobind</code></td>
<td style="text-align: left;"><code>extend</code></td>
<td style="text-align: left;"><code>Extend</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Comultiply</code> (<code>δ</code>)</td>
<td style="text-align: left;"><code>duplicate</code></td>
<td style="text-align: left;"><code>Duplicate</code></td>
</tr>
</tbody>
</table>
<h3 id="ienumerablet"><code>IEnumerable&lt;T&gt;</code></h3>
<h3 id="nullablet"><code>Nullable&lt;T&gt;</code></h3>
<h3 id="funct"><code>Func&lt;T&gt;</code></h3>
<h3 id="lazyt"><code>Lazy&lt;T&gt;</code></h3>
<h3 id="taskt"><code>Task&lt;T&gt;</code></h3>
<p>Reference: <a href="http://blogs.msdn.com/b/pfxteam/archive/2013/04/03/tasks-monads-and-linq.aspx">Stephen Toub</a></p>
<h3 id="maybet"><code>Maybe&lt;T&gt;</code></h3>
<h3 id="state">State</h3>
<h3 id="write">Write</h3>
<h3 id="reader">Reader</h3>
<h3 id="errort"><code>Error&lt;T&gt;</code></h3>
<h2 id="an-haskell-to-c-dictionary">An Haskell to C# Dictionary</h2>
<p>All variants that return a <code>Monad&lt;Unit&gt;</code> instead of a <code>Monad&lt;T&gt;</code> (those that have a postfix <code>_</code>) are not implemented; ignoring the result achieves the same effect.</p>
<h3 id="monad-1">Monad</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">C#</th>
<th style="text-align: left;">Haskell</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Select</code></td>
<td style="text-align: left;"><code>fmap :: (a -&gt; b) -&gt; m a -&gt; m b</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Bind</code></td>
<td style="text-align: left;"><code>(&gt;&gt;=) :: forall a b. m a -&gt; (a -&gt; m b) -&gt; m b</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Then</code></td>
<td style="text-align: left;"><code>(&gt;&gt;) :: forall a b. m a -&gt; m b -&gt; m b</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Monad.Return</code></td>
<td style="text-align: left;"><code>return :: a -&gt; m a</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">(1)</td>
<td style="text-align: left;"><code>fail :: String -&gt; m a</code></td>
</tr>
</tbody>
</table>
<p><em>1.</em> We do not implement <code>fail</code> as .NET has its own way of reporting errors.</p>
<h3 id="monadplus-2">MonadPlus</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">C#</th>
<th style="text-align: left;">Haskell</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Zero</code></td>
<td style="text-align: left;"><code>mzero :: m a</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Plus</code></td>
<td style="text-align: left;"><code>mplus :: m a -&gt; m a -&gt; m a</code></td>
</tr>
</tbody>
</table>
<h3 id="basic-monad-functions">Basic Monad functions</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">C#</th>
<th style="text-align: left;">Haskell</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Func.Map</code></td>
<td style="text-align: left;"><code>mapM :: Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>Ignore</em></td>
<td style="text-align: left;"><code>mapM_ :: Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m ()</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Enumerable&lt;T&gt;.ForEach</code></td>
<td style="text-align: left;"><code>forM :: Monad m =&gt; [a] -&gt; (a -&gt; m b) -&gt; m [b]</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>Ignore</em></td>
<td style="text-align: left;"><code>forM_ :: Monad m =&gt; [a] -&gt; (a -&gt; m b) -&gt; m ()</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Enumerable&lt;Monad&lt;T&gt;&gt;.Collect</code></td>
<td style="text-align: left;"><code>sequence :: Monad m =&gt; [m a] -&gt; m [a]</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><em>Ignore</em></td>
<td style="text-align: left;"><code>sequence_ :: Monad m =&gt; [m a] -&gt; m ()</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Func.Invoke</code></td>
<td style="text-align: left;"><code>(=&lt;&lt;) :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Func.Compose</code></td>
<td style="text-align: left;"><code>(&gt;=&gt;) :: Monad m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Func.ComposeBack</code></td>
<td style="text-align: left;"><code>(&lt;=&lt;) :: Monad m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">(TODO)</td>
<td style="text-align: left;"><code>forever :: Monad m =&gt; m a -&gt; m b</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">(TODO)</td>
<td style="text-align: left;"><code>void :: Functor f =&gt; f a -&gt; f ()</code></td>
</tr>
</tbody>
</table>
<h3 id="generalisations-of-list-functions">Generalisations of list functions</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">C#</th>
<th style="text-align: left;">Haskell</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Monad.Flatten</code></td>
<td style="text-align: left;"><code>join :: Monad m =&gt; m (m a) -&gt; m a</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Enumerable&lt;Monad&lt;T&gt;&gt;.Sum</code></td>
<td style="text-align: left;"><code>msum :: MonadPlus m =&gt; [m a] -&gt; m a</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Filter</code></td>
<td style="text-align: left;"><code>mfilter :: MonadPlus m =&gt; (a -&gt; Bool) -&gt; m a -&gt; m a</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Enumerable&lt;T&gt;.Filter</code></td>
<td style="text-align: left;"><code>filterM :: Monad m =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m [a]</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Enumerable&lt;T&gt;.MapAndUnzip</code></td>
<td style="text-align: left;"><code>mapAndUnzipM :: Monad m =&gt; (a -&gt; m (b, c)) -&gt; [a] -&gt; m ([b], [c])</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Enumerable&lt;T&gt;.Zip</code></td>
<td style="text-align: left;"><code>zipWithM :: Monad m =&gt; (a -&gt; b -&gt; m c) -&gt; [a] -&gt; [b] -&gt; m [c]</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>Ignore</em></td>
<td style="text-align: left;"><code>zipWithM_ :: Monad m =&gt; (a -&gt; b -&gt; m c) -&gt; [a] -&gt; [b] -&gt; m ()</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Enumerable&lt;T&gt;.Fold</code></td>
<td style="text-align: left;"><code>foldM :: Monad m =&gt; (a -&gt; b -&gt; m a) -&gt; a -&gt; [b] -&gt; m a</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>Ignore</em></td>
<td style="text-align: left;"><code>foldM_ :: Monad m =&gt; (a -&gt; b -&gt; m a) -&gt; a -&gt; [b] -&gt; m ()</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Repeat</code></td>
<td style="text-align: left;"><code>replicateM :: Monad m =&gt; Int -&gt; m a -&gt; m [a]</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><em>Ignore</em></td>
<td style="text-align: left;"><code>replicateM_ :: Monad m =&gt; Int -&gt; m a -&gt; m ()</code></td>
</tr>
</tbody>
</table>
<h3 id="conditional-execution-of-monadic-expressions">Conditional execution of monadic expressions</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">C#</th>
<th style="text-align: left;">Haskell</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Monad.Guard</code></td>
<td style="text-align: left;"><code>guard :: MonadPlus m =&gt; Bool -&gt; m ()</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">(1)</td>
<td style="text-align: left;"><code>when :: Monad m =&gt; Bool -&gt; m () -&gt; m ()</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">(1)</td>
<td style="text-align: left;"><code>unless :: Monad m =&gt; Bool -&gt; m () -&gt; m ()</code></td>
</tr>
</tbody>
</table>
<p><em>1.</em> <code>when</code> and <code>unless</code> are related to the way I/O operations are handled in Haskell.</p>
<h3 id="monadic-lifting-operators">Monadic lifting operators</h3>
<p>Implemented as both static methods (<code>Monad.Lift</code>) and extension methods.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">C#</th>
<th style="text-align: left;">Haskell</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Map</code></td>
<td style="text-align: left;"><code>liftM :: Monad m =&gt; (a1 -&gt; r) -&gt; m a1 -&gt; m r</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Monad&lt;T&gt;.SelectMany</code></td>
<td style="text-align: left;"><code>liftM2 :: Monad m =&gt; (a1 -&gt; a2 -&gt; r) -&gt; m a1 -&gt; m a2 -&gt; m r</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Zip</code></td>
<td style="text-align: left;"><code>liftM3 :: Monad m =&gt; (a1 -&gt; a2 -&gt; a3 -&gt; r) -&gt; m a1 -&gt; m a2 -&gt; m a3 -&gt; m r</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Zip</code></td>
<td style="text-align: left;"><code>liftM4 :: Monad m =&gt; (a1 -&gt; a2 -&gt; a3 -&gt; a4 -&gt; r) -&gt; m a1 -&gt; m a2 -&gt; m a3 -&gt; m a4 -&gt; m r</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Zip</code></td>
<td style="text-align: left;"><code>liftM5 :: Monad m =&gt; (a1 -&gt; a2 -&gt; a3 -&gt; a4 -&gt; a5 -&gt; r) -&gt; m a1 -&gt; m a2 -&gt; m a3 -&gt; m a4 -&gt; m a5 -&gt; m r</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">(TODO</td>
<td style="text-align: left;"><code>ap :: Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b</code></td>
</tr>
</tbody>
</table>
<h3 id="extras">Extras</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">C#</th>
<th style="text-align: left;">Haskell (if it existed)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Coalesce</code></td>
<td style="text-align: left;"><code>coalesce :: Monad m =&gt; (a -&gt; Bool) -&gt; m a -&gt; m b -&gt; m b -&gt; m b</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Then</code></td>
<td style="text-align: left;"><code>then :: MonadPlus m =&gt; (a -&gt; Bool) -&gt; m a -&gt; m b -&gt; m b</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Otherwise</code></td>
<td style="text-align: left;"><code>otherwise :: MonadPlus m =&gt; (a -&gt; Bool) -&gt; m a -&gt; m b -&gt; m b</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Monad&lt;T&gt;.When</code></td>
<td style="text-align: left;"><code>when :: Monad m =&gt; Bool -&gt; m a -&gt; () -&gt; m a</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Unless</code></td>
<td style="text-align: left;"><code>unless :: Monad m =&gt; Bool -&gt; m a -&gt; () -&gt; m a</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Invoke</code></td>
<td style="text-align: left;"><code>invoke :: MonadPlus m =&gt; m a -&gt; (a -&gt; m ()) -&gt; m () -&gt; m a</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Monad&lt;T&gt;.OnZero</code></td>
<td style="text-align: left;"><code>onzero :: MonadPlus m =&gt; m a -&gt; m () -&gt; m ()</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Monad&lt;T&gt;.Invoke</code></td>
<td style="text-align: left;"><code>invoke :: Monad m =&gt; m a -&gt; (a -&gt; m ()) -&gt; m ()</code></td>
</tr>
</tbody>
</table>
<h2 id="implementations">Implementations</h2>
<p>Implementations in .NET:</p>
<ul>
<li><a href="https://github.com/iSynaptic/iSynaptic.Commons">iSynaptic.Commons</a> in C#</li>
<li><a href="http://sharpmalib.codeplex.com/">SharpMaLib</a> in F#</li>
</ul>
<footer>
  &copy; 2015 <a href="http://github.com/chtoucas">Narvalo.Org</a>
</footer>
<script src="assets/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
