<?xml version="1.0" encoding="utf-8" ?>
<Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- Define the CodeTaskFactoryAssemblyFile property. -->
  <PropertyGroup>
    <CodeTaskFactoryAssemblyFile>$(MSBuildToolsPath)\Microsoft.Build.Tasks.v$(MSBuildToolsVersion).dll</CodeTaskFactoryAssemblyFile>
  </PropertyGroup>

  <UsingTask TaskName="GenerateBuildAndRevisionNumbers" TaskFactory="CodeTaskFactory" AssemblyFile="$(CodeTaskFactoryAssemblyFile)">
    <ParameterGroup>
      <BuildNumber ParameterType="System.UInt16" Output="true" />
      <RevisionNumber ParameterType="System.UInt16" Output="true" />
    </ParameterGroup>
    <Task>
      <Reference Include="System.Core" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
// The algorithm used by .NET to auto-increment the assembly version is as follows:
//   The default build number increments daily. The default revision number is
//   the number of seconds since midnight local time (without taking into account
//   time zone adjustments for daylight saving time), divided by 2.
// For further informations, see:
// http://msdn.microsoft.com/en-us/library/system.reflection.assemblyversionattribute.aspx
//
// Remarks:
// - this feature is only available to AssemblyVersion not to AssemblyFileVersion.
// - during the same day, two builds may end up with the same assembly version.
// - build and revision numbers must be less or equal to 65534 (UInt16.MaxValue - 1).
//
// Here I implement a slight variation of the same algorithm:
// - use UTC time.
// - the build number is the number of half-days since 2014-12-01 
//   (minus one to start at zero).
// - the revision number is the number of seconds since midnight in the morning 
//   and since midday in the afternoon.
// This way, there is less chance of getting the same numbers during 
// a single day on the same build machine. The scheme will break in 
// approximately 89 years...
// Worth reminding, if we used a scheme that simply incremented the build 
// numbers, we would generate a lot of unecessary holes in the sequence.
// Indeed due to incremental batching a build might not do anything.
// That's a good reason to use an algorithm that only depends on the date 
// and the time.
var now = DateTime.UtcNow;
var isMorning = now.Hour < 12;
var numberOfHalfDays = 2 * (now - new DateTime(2014, 11, 30)).Days - (isMorning ? 1 : 0);
var numberOfSeconds = (now - new DateTime(now.Year, now.Month, now.Day, isMorning ? 0 : 12, 0, 0)).TotalSeconds;

BuildNumber = (ushort)(numberOfHalfDays - 1);
RevisionNumber = (ushort)numberOfSeconds;

return !Log.HasLoggedErrors;
         ]]>
      </Code>
    </Task>
  </UsingTask>

  <!-- Create an ever growing integer key from the build and revision numbers. -->
  <UsingTask TaskName="GenerateBuildStamp" TaskFactory="CodeTaskFactory" AssemblyFile="$(CodeTaskFactoryAssemblyFile)">
    <ParameterGroup>
      <BuildNumber ParameterType="System.UInt16" Required="true" />
      <RevisionNumber ParameterType="System.UInt16" Required="true" />

      <BuildStamp ParameterType="System.String" Output="true" />
    </ParameterGroup>
    <Task>
      <Reference Include="System.Core" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
BuildStamp = BuildNumber.ToString();        

var revisionString = RevisionNumber.ToString();

for (int i = 0; i < 5 - revisionString.Length; i++) { BuildStamp += "0"; }

BuildStamp += revisionString;

return !Log.HasLoggedErrors;
         ]]>
      </Code>
    </Task>
  </UsingTask>

  <UsingTask TaskName="WriteNuspec" TaskFactory="CodeTaskFactory" AssemblyFile="$(CodeTaskFactoryAssemblyFile)">
    <ParameterGroup>
      <TemplateFile ParameterType="System.String" Required="true" />
      <OutFile ParameterType="System.String" Required="true" />

      <Id ParameterType="System.String" Required="true" />
      <Version ParameterType="System.String" Required="true" />
      <Description ParameterType="System.String" Required="true" />
      <Files ParameterType="System.String" Required="true" />

      <Title ParameterType="System.String" />
      <Summary ParameterType="System.String" />
      <ReleaseNotes ParameterType="System.String" />
      <Copyright ParameterType="System.String" />
      <Tags ParameterType="System.String" />
      <Dependencies ParameterType="System.String" />
      <References ParameterType="System.String" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Using Namespace="Microsoft.Build.Framework" />
      <Using Namespace="Microsoft.Build.Utilities" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
try {
    string nuspec = File.ReadAllText(TemplateFile)
      .Replace("$id$", Id)
      .Replace("$version$", Version)
      .Replace("$description$", Description)
      .Replace("$files$", Files)
      
      .Replace("$title$", String.IsNullOrWhiteSpace(Title) ? String.Empty : "<title>" + Title + "</title>")
      .Replace("$summary$", String.IsNullOrWhiteSpace(Summary) ? String.Empty : "<summary>" + Summary + "</summary>")
      .Replace("$releaseNotes$", String.IsNullOrWhiteSpace(ReleaseNotes) ? String.Empty : "<releaseNotes>" + ReleaseNotes + "</releaseNotes>")
      .Replace("$copyright$", String.IsNullOrWhiteSpace(Copyright) ? String.Empty : "<copyright>" + String.Format(Copyright, DateTime.Now.Year) + "</copyright>")
      .Replace("$tags$", String.IsNullOrWhiteSpace(Tags) ? String.Empty : "<tags>" + Tags + "</tags>")
      .Replace("$dependencies$", String.IsNullOrWhiteSpace(Dependencies) ? String.Empty : "<dependencies>" + Dependencies + "</dependencies>")
      .Replace("$references$", String.IsNullOrWhiteSpace(References) ? String.Empty : References)
      ;
    
    File.WriteAllText(OutFile, nuspec);
}
catch (IOException ex) {
    Log.LogErrorFromException(ex);
}

return !Log.HasLoggedErrors;
        ]]>
      </Code>
    </Task>
  </UsingTask>

  <UsingTask TaskName="FindProductVersion" TaskFactory="CodeTaskFactory" AssemblyFile="$(CodeTaskFactoryAssemblyFile)">
    <ParameterGroup>
      <AssemblyPath ParameterType="System.String" Required="true" />
      <ProductVersion ParameterType="System.String" Output="true" />
    </ParameterGroup>
    <Task>
      <Reference Include="System.Xml" />
      <Reference Include="System.Xml.Linq"/>
      <Using Namespace="System" />
      <Using Namespace="System.Diagnostics" />
      <Using Namespace="System.IO" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
var version = FileVersionInfo.GetVersionInfo(AssemblyPath).ProductVersion ;
int index = version.LastIndexOf("+");
ProductVersion = index > 0 ? version.Remove(index) : version;

return !Log.HasLoggedErrors;
        ]]>
      </Code>
    </Task>
  </UsingTask>

  <!-- Quick and dirty task to transform a packages.config to a dependencies XML string usable in nuspec. -->
  <UsingTask TaskName="ReadDependenciesFromPackagesConfig" TaskFactory="CodeTaskFactory" AssemblyFile="$(CodeTaskFactoryAssemblyFile)">
    <ParameterGroup>
      <Config ParameterType="System.String" Required="true" />
      <Dependencies ParameterType="System.String" Output="true" />
    </ParameterGroup>
    <Task>
      <Reference Include="System.Xml" />
      <Reference Include="System.Xml.Linq"/>
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.Xml" />
      <Using Namespace="System.Xml.Linq" />
      <Using Namespace="Microsoft.Build.Framework" />
      <Using Namespace="Microsoft.Build.Utilities" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
using (var reader = XmlReader.Create(Config)) {
  var rootElement = XElement.Load(reader, LoadOptions.None);

  var packages = rootElement.Elements("package");
  
  foreach (var package in packages) {
    Dependencies += String.Format(
      "\n<dependency id=\"{0}\" version=\"{1}\" />",
      package.Attribute("id").Value, 
      package.Attribute("version").Value); 
  }
  
  if (Dependencies.Length != 0) {
    Dependencies += "\n    ";
  }
}

return !Log.HasLoggedErrors;
        ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>