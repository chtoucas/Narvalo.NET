<?xml version="1.0" encoding="utf-8" ?>
<Project ToolsVersion="12.0"
         InitialTargets="__InitializeMakeCustomAfterTargets"
         xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- This file is injected at the end of Narvalo.Common.targets by Make.proj. -->

  <!-- Import custom tasks, if not already done. -->
  <Import Project="$(MSBuildThisFileDirectory)Make.Custom.tasks"
          Condition=" '$(MakeCustomTasksImported)' != 'true' "/>

  <!-- Import the T4 targets. -->
  <PropertyGroup>
    <TextTemplatingTargetsPath>$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TextTemplating\Microsoft.TextTemplating.targets</TextTemplatingTargetsPath>
  </PropertyGroup>

  <Import Project="$(TextTemplatingTargetsPath)" Condition="Exists('$(TextTemplatingTargetsPath)')" />

  <!-- Append to the BeforeBuildDependsOn property. -->
  <PropertyGroup>
    <BeforeBuildDependsOn>
      $(BeforeBuildDependsOn);
      CreateAssemblyVersionFile
    </BeforeBuildDependsOn>
  </PropertyGroup>

  <!-- Append to the AfterBuildDependsOn property. -->
  <PropertyGroup>
    <AfterBuildDependsOn>
      $(AfterBuildDependsOn);
      DeleteOriginalDocumentationFile
    </AfterBuildDependsOn>
  </PropertyGroup>

  <!-- Append to the CleanDependsOn property. -->
  <PropertyGroup>
    <CleanDependsOn>
      $(CleanDependsOn);
      DeleteAssemblyVersionFile;
      DeleteNupkgFile;
      DeleteNuspecFile;
      DeletePEVerifyDummyOutput;
      DeletePEVerifyLogFile;
      DeleteSecAnnotateLogFile;
      DeleteSecAnnotateOutput
    </CleanDependsOn>
  </PropertyGroup>

  <!-- Package target. -->
  <Target Name="Package" DependsOnTargets="CreateNupkg" />

  <!-- DeleteOriginalDocumentationFile target. -->
  <Target Name="DeleteOriginalDocumentationFile" Condition=" '$(BuildCodeContractsReferenceAssembly)' == 'true' ">
    <Message Text="Deleting original documentation files (before the Code Contracts transformation)..." Importance="normal" />

    <Delete Files="$(OriginalDocumentationFile)" />
  </Target>

  <!-- GenerateBuildAndRevisionNumbers target. -->
  <Target Name="GenerateBuildAndRevisionNumbers">
    <GenerateBuildAndRevisionNumbers>
      <Output TaskParameter="BuildNumber" PropertyName="BuildNumber"/>
      <Output TaskParameter="RevisionNumber" PropertyName="RevisionNumber"/>
    </GenerateBuildAndRevisionNumbers>
  </Target>

  <!-- GenerateBuildStamp target. -->
  <Target Name="GenerateBuildStamp" DependsOnTargets="GenerateBuildAndRevisionNumbers">
    <GenerateBuildStamp BuildNumber="$(BuildNumber)" RevisionNumber="$(RevisionNumber)">
      <Output TaskParameter="BuildStamp" PropertyName="BuildStamp"/>
    </GenerateBuildStamp>
  </Target>

  <!-- ### Build Generated Version ### -->

  <!-- CreateAssemblyVersionFile target. -->
  <Target Name="CreateAssemblyVersionFile"
          Condition=" '$(BuildGeneratedVersion)' == 'true' "
          DependsOnTargets="DeleteAssemblyVersionFile;GenerateBuildAndRevisionNumbers">
    <Message Text="Creating the assembly version file for $(AssemblyName)..." Importance="normal" />

    <Error Text="You MUST create a version file to generate the assembly versions: $(VersionFile)."
           Condition=" '$(VersionExists)' != 'true' " />

    <PropertyGroup>
      <_BuildMetadata>$(Configuration)</_BuildMetadata>
      <_BuildMetadata>$(_BuildMetadata)+$(Platform)</_BuildMetadata>
      <_BuildMetadata Condition=" '$(SignAssembly)' == 'true' ">$(_BuildMetadata)+Signed</_BuildMetadata>
      <_BuildMetadata Condition=" '$(SignAssembly)' != 'true' ">$(_BuildMetadata)+Unsigned</_BuildMetadata>
      <_BuildMetadata Condition=" '$(BuildGeneratedVersion)' == 'true' ">$(_BuildMetadata)+SemVer</_BuildMetadata>
      <_BuildMetadata Condition=" '$(BuildGeneratedVersion)' != 'true' ">$(_BuildMetadata)+NotVer</_BuildMetadata>
      <_BuildMetadata Condition=" '$(VisibleInternals)' == 'true' ">$(_BuildMetadata)+Leaky</_BuildMetadata>
      <_BuildMetadata Condition=" '$(VisibleInternals)' != 'true' ">$(_BuildMetadata)+Closed</_BuildMetadata>

      <_ConfigurationMetadata Condition=" '$(Retail)' == 'true' ">Retail</_ConfigurationMetadata>
      <_ConfigurationMetadata Condition=" '$(Retail)' != 'true' ">$(_BuildMetadata)</_ConfigurationMetadata>

      <_AssemblyConfiguration>$(_ConfigurationMetadata) built on $([System.DateTime]::UtcNow.ToString()).</_AssemblyConfiguration>
      <_AssemblyVersion>$(MajorVersion).$(MinorVersion).0.0</_AssemblyVersion>
      <_AssemblyFileVersion>$(MajorVersion).$(MinorVersion).$(BuildNumber).$(RevisionNumber)</_AssemblyFileVersion>
      <_AssemblyInformationalVersion>$(SemanticVersion)+$(_BuildMetadata.Replace('+', '.').ToLowerInvariant())</_AssemblyInformationalVersion>

      <_AssemblyVersionContent>
        <![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by a tool. Changes to this file may cause incorrect
// behavior and will be lost when the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Reflection;

#if BUILD_GENERATED_VERSION
[assembly: AssemblyConfiguration("$(_AssemblyConfiguration)")]
[assembly: AssemblyVersion("$(_AssemblyVersion)")]
[assembly: AssemblyFileVersion("$(_AssemblyFileVersion)")]
[assembly: AssemblyInformationalVersion("$(_AssemblyInformationalVersion)")]
#endif

         ]]>
      </_AssemblyVersionContent>
      <_AssemblyVersionLines>$([MSBuild]::Escape($(_AssemblyVersionContent)))</_AssemblyVersionLines>
      <_ParentDirectoryOfAssemblyVersionFile>$([System.IO.Path]::GetDirectoryName($(AssemblyVersionFile)))</_ParentDirectoryOfAssemblyVersionFile>
    </PropertyGroup>

    <MakeDir Directories="$(_ParentDirectoryOfAssemblyVersionFile)"
             Condition=" !Exists($(_ParentDirectoryOfAssemblyVersionFile)) " />

    <WriteLinesToFile Lines="$(_AssemblyVersionLines)" File="$(AssemblyVersionFile)" Overwrite="true" />
  </Target>

  <!-- DeleteAssemblyVersionFile target. -->
  <Target Name="DeleteAssemblyVersionFile" Condition=" '$(BuildGeneratedVersion)' == 'true' ">
    <Delete Files="$(AssemblyVersionFile)" />
  </Target>

  <!-- ### PEVerify ### -->

  <!-- DeletePEVerifyLogFile target. -->
  <Target Name="DeletePEVerifyLogFile">
    <Delete Files="$(PEVerifyLogFile)" />
  </Target>

  <!-- DeletePEVerifyDummyOutput target. -->
  <Target Name="DeletePEVerifyDummyOutput">
    <Delete Files="$(PEVerifyDummyOutput)" />
  </Target>

  <!-- Define the CorePEVerify property. -->
  <PropertyGroup>
    <CorePEVerify>_PEVerify</CorePEVerify>
    <CorePEVerify Condition=" !Exists('$(PEVerifyCommand)') ">_WarnOnMissingPEVerify</CorePEVerify>
  </PropertyGroup>

  <!-- PEVerify target. -->
  <!-- WARNING: Delete previous log before doing anything. We append to it
       and we don't want to let it grow endlessly. The obvious side-effect is
       that we can not use the log file for incremental batching. -->
  <Target Name="PEVerify" DependsOnTargets="DeletePEVerifyLogFile;$(CorePEVerify)" />

  <!-- _PEVerify target. -->
  <Target Name="_PEVerify"
          DependsOnTargets="Build"
          Inputs="$(TargetPath)"
          Outputs="$(PEVerifyDummyOutput)">
    <Message Text="Verifying $(AssemblyName) with PEVerify..." Importance="high" />

    <Exec Command="&quot;$(PEVerifyCommand)&quot; &quot;$(TargetPath)&quot; /nologo /md /il /unique >> &quot;$(PEVerifyLogFile)&quot;"
          LogStandardErrorAsError="true"
          ContinueOnError="false" />

    <!-- Keep this at the end of the target, in case one of the PEVerify executions failed. -->
    <Touch Files="$(PEVerifyDummyOutput)" AlwaysCreate="true" />
  </Target>

  <!-- _WarnOnMissingPEVerify target. -->
  <Target Name="_WarnOnMissingPEVerify">
    <Warning Text="Cannot verify assemblies. I was unable to locate PEVerify.exe. It is part of the Visual Studio installation or the lighter .NET Framework SDK." />
  </Target>

  <!-- ### SecAnnotate ### -->

  <!-- DeleteSecAnnotateLogFile target. -->
  <Target Name="DeleteSecAnnotateLogFile">
    <Delete Files="$(SecAnnotateLogFile)" />
  </Target>

  <!-- DeleteSecAnnotateOutput target. -->
  <Target Name="DeleteSecAnnotateOutput">
    <Delete Files="$(SecAnnotateOutput)" />
  </Target>

  <!-- Define the CoreSecAnnotate property. -->
  <PropertyGroup>
    <CoreSecAnnotate>_SecAnnotate</CoreSecAnnotate>
    <CoreSecAnnotate Condition=" !Exists('$(SecAnnotateCommand)') ">_WarnOnMissingSecAnnotate</CoreSecAnnotate>
  </PropertyGroup>

  <!-- SecAnnotate target. -->
  <!-- WARNING: Delete previous log before doing anything. We append to it
       and we don't want to let it grow endlessly. As a side-effect, we can not
       use the log file for incremental batching. -->
  <Target Name="SecAnnotate" DependsOnTargets="DeleteSecAnnotateLogFile;$(CoreSecAnnotate)" />

  <!-- _SecAnnotate target. -->
  <Target Name="_SecAnnotate"
          DependsOnTargets="Build"
          Inputs="$(TargetPath)"
          Outputs="$(SecAnnotateOutput)">
    <!-- FIXME: SecAnnotateOutput is not currently written... -->
    <Message Text="Analyzing $(AssemblyName) with SecAnnotate..." Importance="high" />

    <!-- /maximumpasses:1  /quiet -->
    <Exec Command="&quot;$(SecAnnotateCommand)&quot; /showstatistics /verify /verbose /out:&quot;$(SecAnnotateOutput)&quot; &quot;$(TargetPath)&quot; >> &quot;$(SecAnnotateLogFile)&quot;"
          WorkingDirectory="$(OutDir)"
          LogStandardErrorAsError="true"
          ContinueOnError="false" />
  </Target>

  <!-- _WarnOnMissingSecAnnotate target. -->
  <Target Name="_WarnOnMissingSecAnnotate">
    <Warning Text="Cannot analyze assemblies for transparency violations. I was unable to locate SecAnnotate.exe. It is part of the Visual Studio installation or the lighter .NET Framework SDK." />
  </Target>

  <!-- ### NuGet packaging ### -->

  <!-- CreateNupkg target. -->
  <Target Name="CreateNupkg"
          Condition=" '$(NuProjectExists)' == 'true' "
          DependsOnTargets="DeleteNupkgFile;Build;CreateNuspec">
    <Message Text="Creating package for $(AssemblyName)..." Importance="high" />

    <!-- REVIEW: Why can't I quote WorkPackagesDir? -->
    <Exec Command="&quot;$(NuGetCommand)&quot; pack &quot;$(NuspecFile)&quot; -OutputDirectory $(WorkPackagesDir) $(NuGetCommandAdditionalArgs) -NonInteractive -Verbosity quiet"
          LogStandardErrorAsError="true"
          ContinueOnError="false" />
  </Target>

  <!-- CreateNuspec target. -->
  <Target Name="CreateNuspec"
          Condition=" '$(NuProjectExists)' == 'true' "
          DependsOnTargets="DeleteNuspecFile;FindNuGetDependencies;FindProjectDependencies">
    <Message Text="Creating nuspec for $(AssemblyName)..." Importance="normal" />

    <!-- To create a nupkg we need a meaningful version:
         * BuildGeneratedVersion=true, ie the assembly gets an actual version,
           which implies VersionExists = true.
         * the package has a unique version that matchs the assembly version. -->
    <Error Text="You MUST use 'BuildGeneratedVersion=true' to create a NuGet package."
           Condition=" '$(BuildGeneratedVersion)' != 'true' " />

    <WriteNuspec TemplateFile="$(RepositorySettingsDir)Template.nuspec"
                 OutFile="$(NuspecFile)"

                 Id="$(NuId)"
                 Version="$(NuVersion)"
                 Description="$(NuDescription)"
                 Files="$(NuFiles)"

                 Title="$(NuTitle)"
                 Summary="$(NuSummary)"
                 ReleaseNotes="$(NuReleaseNotes)"
                 Copyright="$(NuCopyright)"
                 Tags="$(NuTags)"
                 Dependencies="$(ProjectDependencies)$(NuGetDependencies)"
                 References="$(NuReferences)" />
  </Target>

  <!-- DeleteNupkgFile target. -->
  <Target Name="DeleteNupkgFile"
          Condition=" '$(NuProjectExists)' == 'true' And '$(Retail)' == 'true' ">
    <!-- No need to try to delete a non-retail packages. Its name changes over time. -->
    <PropertyGroup>
      <_NupkgFile>$(WorkPackagesDir)$(NuId).$(NuVersion).nupkg</_NupkgFile>
    </PropertyGroup>

    <Delete Files="$(_NupkgFile)" />
  </Target>

  <!-- DeleteNuspecFile target. -->
  <Target Name="DeleteNuspecFile" Condition=" '$(NuProjectExists)' == 'true' ">
    <Delete Files="$(NuspecFile)" />
  </Target>

  <!-- FindNuGetDependencies target. -->
  <Target Name="FindNuGetDependencies" Condition=" Exists('$(PackagesConfig)') ">
    <Message Text="Reading packages.config for NuGet dependencies of $(AssemblyName)..." Importance="normal" />

    <ReadDependenciesFromPackagesConfig Config="$(PackagesConfig)">
      <Output TaskParameter="Dependencies" PropertyName="NuGetDependencies"/>
    </ReadDependenciesFromPackagesConfig>
  </Target>

  <!-- FindProjectDependencies target. -->
  <Target Name="FindProjectDependencies" DependsOnTargets="ReadProjectDependency">
    <Message Text="Finding local project dependencies for $(AssemblyName)..." Importance="normal" />

    <PropertyGroup>
      <ProjectDependencies>@(ProjectDependency -> '%(XmlFragment)', '')</ProjectDependencies>
    </PropertyGroup>
  </Target>

  <!-- ReadProjectDependency target. -->
  <Target Name="ReadProjectDependency"
          Condition=" '@(ProjectReference)' != '' "
          Outputs="%(ProjectReference.Identity)">
    <FindProductVersion AssemblyPath="$(OutDir)%(ProjectReference.Name).dll">
      <Output TaskParameter="ProductVersion" PropertyName="_ProjectDependencyVersion"/>
    </FindProductVersion>

    <PropertyGroup>
      <_ProjectDependencyId>%(ProjectReference.Name)</_ProjectDependencyId>
    </PropertyGroup>

    <PropertyGroup Condition=" '$(Retail)' != 'true' ">
      <_ProjectDependencyId>$(_ProjectDependencyId).$(EDGE)</_ProjectDependencyId>
      <_ProjectDependencyVersion>(,$(_ProjectDependencyVersion)]</_ProjectDependencyVersion>
    </PropertyGroup>

    <ItemGroup>
      <ProjectDependency Include="$(_ProjectDependencyId)">
        <XmlFragment>
          <![CDATA[
<dependency id="$(_ProjectDependencyId)" version="$(_ProjectDependencyVersion)" />
          ]]>
        </XmlFragment>
      </ProjectDependency>
    </ItemGroup>
  </Target>

  <!-- __InitializeMakeCustomAfterTargets target. -->
  <Target Name="__InitializeMakeCustomAfterTargets" DependsOnTargets="__PatchNuProject" />

  <!-- __PatchNuProject targets. -->
  <Target Name="__PatchNuProject"
          Condition=" '$(NuProjectExists)' == 'true' And '$(Retail)' != 'true' "
          DependsOnTargets="GenerateBuildStamp">
    <!-- For non-retail packages, we change on-the-fly various bits. -->
    <PropertyGroup>
      <EDGE>EDGE</EDGE>
      
      <NuId>$(NuId).$(EDGE)</NuId>
      <NuTitle Condition=" '$(NuTitle)' != '' ">$(NuTitle) ($(EDGE))</NuTitle>
      <NuVersion>$(MajorVersion).$(MinorVersion).$(PatchVersion)-T$(BuildStamp)</NuVersion>
    </PropertyGroup>
  </Target>
</Project>