<?xml version="1.0" encoding="utf-8" ?>
<Project ToolsVersion="14.0"
         InitialTargets="__InitializeMakeCustomAfterTargets"
         xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- This file is injected at the end of Narvalo.Common.targets by Make.proj. -->

  <!-- Import custom tasks, if not already done. -->
  <Import Project="$(MSBuildThisFileDirectory)Make.Custom.tasks"
          Condition=" '$(MakeCustomTasksImported)' != 'true' "/>

  <!-- Import the T4 targets. -->
  <PropertyGroup>
    <TextTemplatingTargetsPath>$(MSBuildExtensionsPath)\Microsoft\VisualStudio\v$(VisualStudioVersion)\TextTemplating\Microsoft.TextTemplating.targets</TextTemplatingTargetsPath>
  </PropertyGroup>

  <Import Project="$(TextTemplatingTargetsPath)" Condition="Exists('$(TextTemplatingTargetsPath)')" />

  <!-- Append to the BeforeBuildDependsOn property. -->
  <PropertyGroup>
    <BeforeBuildDependsOn>
      $(BeforeBuildDependsOn);
      CreateAssemblyVersionFile
    </BeforeBuildDependsOn>
  </PropertyGroup>

  <!-- Append to the AfterBuildDependsOn property. -->
  <PropertyGroup>
    <AfterBuildDependsOn>
      $(AfterBuildDependsOn);
      PatchDocumentationFiles
    </AfterBuildDependsOn>
  </PropertyGroup>

  <!-- Append to the CleanDependsOn property. -->
  <PropertyGroup>
    <CleanDependsOn>
      $(CleanDependsOn);
      DeleteAssemblyVersionFile;
      DeleteNupkgFile;
      DeleteNuspecFile;
      DeletePEVerifyDummyOutput;
      DeletePEVerifyLogFile;
      DeleteSecAnnotateDummyOutput;
      DeleteSecAnnotateLogFile;
      DeleteSecAnnotateOutput
    </CleanDependsOn>
  </PropertyGroup>

  <!-- Package target. -->
  <!-- WARNING: Some projects might also define a Package target which will override this one. -->
  <Target Name="Package" DependsOnTargets="CreateNupkg" />

  <!-- PatchDocumentationFiles target. -->
  <Target Name="PatchDocumentationFiles" Condition=" '$(CodeContractsEmitXMLDocs)' == 'true' ">
    <Message Text="Patching documentation files (after the Code Contracts transformation)..." Importance="normal" />

    <Move SourceFiles="$(DocumentationFile)"  DestinationFiles="$(CodeContractsDocumentationFile)" />
    <Move SourceFiles="$(OriginalDocumentationFile)"  DestinationFiles="$(DocumentationFile)" />
  </Target>

  <!-- GenerateBuildAndRevisionNumbers target. -->
  <Target Name="GenerateBuildAndRevisionNumbers">
    <GenerateBuildAndRevisionNumbers>
      <Output TaskParameter="BuildNumber" PropertyName="BuildNumber"/>
      <Output TaskParameter="RevisionNumber" PropertyName="RevisionNumber"/>
    </GenerateBuildAndRevisionNumbers>
  </Target>

  <!-- GenerateBuildStamp target. -->
  <Target Name="GenerateBuildStamp" DependsOnTargets="GenerateBuildAndRevisionNumbers">
    <GenerateBuildStamp BuildNumber="$(BuildNumber)" RevisionNumber="$(RevisionNumber)">
      <Output TaskParameter="BuildStamp" PropertyName="BuildStamp"/>
    </GenerateBuildStamp>
  </Target>

  <!-- ### Build Generated Version ### -->

  <!-- CreateAssemblyVersionFile target. -->
  <Target Name="CreateAssemblyVersionFile"
          Condition=" '$(BuildGeneratedVersion)' == 'true' "
          DependsOnTargets="DeleteAssemblyVersionFile;GenerateBuildAndRevisionNumbers">
    <Message Text="Creating the assembly version file for $(AssemblyName)..." Importance="normal" />

    <Error Text="You MUST create a version file to generate the assembly versions: $(VersionFile)."
           Condition=" '$(VersionExists)' != 'true' " />
    <!-- To get last commit hash we could use https://github.com/loresoft/msbuildtasks.
         NB: MSBuild makes it way too hard to get the console output from an executable. -->
    <Message Text="Won't be able to add the git commit hash to the assembly version information."
             Importance="low"
             Condition=" '$(GitCommitHash)' == '' " />

    <PropertyGroup>
      <_ConfigurationMetadata>$(Configuration)</_ConfigurationMetadata>
      <_ConfigurationMetadata>$(_ConfigurationMetadata)+$(Platform)</_ConfigurationMetadata>
      <_ConfigurationMetadata Condition=" '$(SignAssembly)' == 'true' ">$(_ConfigurationMetadata)+Signed</_ConfigurationMetadata>
      <_ConfigurationMetadata Condition=" '$(SignAssembly)' != 'true' ">$(_ConfigurationMetadata)+Unsigned</_ConfigurationMetadata>
      <_ConfigurationMetadata Condition=" '$(BuildGeneratedVersion)' == 'true' ">$(_ConfigurationMetadata)+SemVer</_ConfigurationMetadata>
      <_ConfigurationMetadata Condition=" '$(BuildGeneratedVersion)' != 'true' ">$(_ConfigurationMetadata)+FakeVer</_ConfigurationMetadata>
      <_ConfigurationMetadata Condition=" '$(VisibleInternals)' == 'true' ">$(_ConfigurationMetadata)+Leaky</_ConfigurationMetadata>
      <_ConfigurationMetadata Condition=" '$(VisibleInternals)' != 'true' ">$(_ConfigurationMetadata)+Closed</_ConfigurationMetadata>
    </PropertyGroup>

    <PropertyGroup Condition=" '$(Retail)' != 'true' ">
      <_BuildMetadata>$(_ConfigurationMetadata.Replace('+', '.').ToLowerInvariant())</_BuildMetadata>
      <_BuildMetadata Condition=" '$(GitCommitHash)' != '' ">$(_BuildMetadata).$(GitCommitHash)</_BuildMetadata>
    </PropertyGroup>

    <!-- For retail builds, we only keep the minimal amount of informations.
         More details are still available in the assembly configuration attribute. -->
    <PropertyGroup Condition=" '$(Retail)' == 'true' ">
      <_BuildMetadata Condition=" '$(GitCommitHash)' != '' ">$(GitCommitHash.Substring(0, 7))</_BuildMetadata>
    </PropertyGroup>

    <PropertyGroup>
      <_AssemblyConfiguration>$(_ConfigurationMetadata) built on $([System.DateTime]::UtcNow.ToString()).</_AssemblyConfiguration>

      <_AssemblyVersion>$(MajorVersion).$(MinorVersion).0.0</_AssemblyVersion>
      <_AssemblyFileVersion>$(MajorVersion).$(MinorVersion).$(BuildNumber).$(RevisionNumber)</_AssemblyFileVersion>
      <_AssemblyInformationalVersion>$(SemanticVersion)</_AssemblyInformationalVersion>
      <_AssemblyInformationalVersion Condition=" '$(_BuildMetadata)' != '' ">$(SemanticVersion)+$(_BuildMetadata)</_AssemblyInformationalVersion>
      <_AssemblyVersionContent>
        <![CDATA[
//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by a tool. Changes to this file may cause incorrect
// behavior and will be lost when the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Reflection;

#if BUILD_GENERATED_VERSION
[assembly: AssemblyConfiguration("$(_AssemblyConfiguration)")]
[assembly: AssemblyVersion("$(_AssemblyVersion)")]
[assembly: AssemblyFileVersion("$(_AssemblyFileVersion)")]
[assembly: AssemblyInformationalVersion("$(_AssemblyInformationalVersion)")]
#endif

         ]]>
      </_AssemblyVersionContent>
      <_AssemblyVersionLines>$([MSBuild]::Escape($(_AssemblyVersionContent)))</_AssemblyVersionLines>
      <_ParentDirectoryOfAssemblyVersionFile>$([System.IO.Path]::GetDirectoryName($(AssemblyVersionFile)))</_ParentDirectoryOfAssemblyVersionFile>
    </PropertyGroup>

    <MakeDir Directories="$(_ParentDirectoryOfAssemblyVersionFile)"
             Condition=" !Exists($(_ParentDirectoryOfAssemblyVersionFile)) " />

    <WriteLinesToFile Lines="$(_AssemblyVersionLines)" File="$(AssemblyVersionFile)" Overwrite="true" />
  </Target>

  <!-- DeleteAssemblyVersionFile target. -->
  <Target Name="DeleteAssemblyVersionFile" Condition=" '$(BuildGeneratedVersion)' == 'true' ">
    <Delete Files="$(AssemblyVersionFile)" />
  </Target>

  <!-- ### PEVerify ### -->

  <!-- DeletePEVerifyLogFile target. -->
  <Target Name="DeletePEVerifyLogFile">
    <Delete Files="$(PEVerifyLogFile)" />
  </Target>

  <!-- DeletePEVerifyDummyOutput target. -->
  <Target Name="DeletePEVerifyDummyOutput">
    <Delete Files="$(PEVerifyDummyOutput)" />
  </Target>

  <!-- Define the CorePEVerify property. -->
  <PropertyGroup>
    <CorePEVerify>_PEVerify</CorePEVerify>
    <CorePEVerify Condition=" !Exists('$(PEVerifyCommand)') ">_WarnOnMissingPEVerify</CorePEVerify>
  </PropertyGroup>

  <!-- PEVerify target. -->
  <!-- WARNING: Delete previous log before doing anything. We append to it
       and we don't want to let it grow endlessly. The obvious side-effect is
       that we can not use the log file for incremental batching. -->
  <Target Name="PEVerify" DependsOnTargets="DeletePEVerifyLogFile;$(CorePEVerify)" />

  <!-- _PEVerify target. -->
  <Target Name="_PEVerify"
          DependsOnTargets="Build"
          Inputs="$(TargetPath)"
          Outputs="$(PEVerifyDummyOutput)">
    <Message Text="Verifying $(AssemblyName) with PEVerify..." Importance="high" />

    <Exec Command="&quot;$(PEVerifyCommand)&quot; &quot;$(TargetPath)&quot; /nologo /md /il /unique >> &quot;$(PEVerifyLogFile)&quot;"
          LogStandardErrorAsError="true"
          ContinueOnError="false" />

    <!-- Keep this at the end of the target, in case one of the PEVerify executions failed. -->
    <Touch Files="$(PEVerifyDummyOutput)" AlwaysCreate="true" />
  </Target>

  <!-- _WarnOnMissingPEVerify target. -->
  <Target Name="_WarnOnMissingPEVerify">
    <Warning Text="Cannot verify assemblies. I was unable to locate PEVerify.exe. It is part of the Visual Studio installation or the lighter .NET Framework SDK." />
  </Target>

  <!-- ### SecAnnotate ### -->

  <!-- DeleteSecAnnotateDummyOutput target. -->
  <Target Name="DeleteSecAnnotateDummyOutput">
    <Delete Files="$(SecAnnotateDummyOutput)" />
  </Target>

  <!-- DeleteSecAnnotateLogFile target. -->
  <Target Name="DeleteSecAnnotateLogFile">
    <Delete Files="$(SecAnnotateLogFile)" />
  </Target>

  <!-- DeleteSecAnnotateOutput target. -->
  <Target Name="DeleteSecAnnotateOutput">
    <Delete Files="$(SecAnnotateOutput)" />
  </Target>

  <!-- Define the CoreSecAnnotate property. -->
  <PropertyGroup>
    <CoreSecAnnotate>_SecAnnotate</CoreSecAnnotate>
    <CoreSecAnnotate Condition=" !Exists('$(SecAnnotateCommand)') ">_WarnOnMissingSecAnnotate</CoreSecAnnotate>
  </PropertyGroup>

  <!-- SecAnnotate target. -->
  <!-- WARNING: Delete previous log before doing anything. We append to it
       and we don't want to let it grow endlessly. As a side-effect, we can not
       use the log file for incremental batching. -->
  <Target Name="SecAnnotate" DependsOnTargets="DeleteSecAnnotateLogFile;$(CoreSecAnnotate)" />

  <!-- _SecAnnotate target. -->
  <Target Name="_SecAnnotate"
          DependsOnTargets="Build"
          Inputs="$(TargetPath)"
          Outputs="$(SecAnnotateDummyOutput)">
    <!-- REVIEW: We use SecAnnotateDummyOutput since SecAnnotateOutput is not always written (for instance
         when there is no error). -->
    <Message Text="Analyzing $(AssemblyName) with SecAnnotate..." Importance="high" />

    <PropertyGroup>
      <!-- WARNING: The directory path must not end with a slash.
           http://stackoverflow.com/questions/12360534/how-can-i-successfully-run-secannotate-exe-on-a-library-that-depends-on-a-portab
           https://github.com/autofac/Autofac/blob/v3.5.2/default.proj
      -->
      <_PortableReferenceDirectory>$(MSBuildProgramFiles32)\Reference Assemblies\Microsoft\Framework\.NETPortable\$(TargetFrameworkVersion)</_PortableReferenceDirectory>
      <_SecAnnotateReferenceDirectory Condition=" '$(TargetFrameworkProfile.StartsWith(Profile))' == 'true' ">/referencedir:"$(_PortableReferenceDirectory)"</_SecAnnotateReferenceDirectory>
      <_SecAnnotateReferenceDirectory>$(_SecAnnotateReferenceDirectory) /referencedir:"$(OutputPath.TrimEnd('\'))"</_SecAnnotateReferenceDirectory>
    </PropertyGroup>

    <PropertyGroup>
    <!-- We force transparency for PCL libraries, otherwise SecAnnotate does not recognize it. -->
      <_ForceTransparency Condition=" '$(AssemblyName)' != 'Narvalo.Cerbere' " >/t:Narvalo.Cerbere.dll</_ForceTransparency>
      <_ForceTransparency Condition=" '$(AssemblyName)' != 'Narvalo.Fx' " >$(_ForceTransparency) /t:Narvalo.Fx.dll</_ForceTransparency>
      <_ForceTransparency Condition=" '$(AssemblyName)' != 'Narvalo.Finance' " >$(_ForceTransparency) /t:Narvalo.Finance.dll</_ForceTransparency>
    </PropertyGroup>

    <!-- WARNING: The /verify switch disable output and other things. From the documentation:
         Verifies only that an assembly's annotations are correct; does not attempt to make multiple passes
         to find all required annotations if the assembly does not verify. -->
    <!-- NB: Available options:
         /maximumpasses:1 to limit the number of passes.
         /includesignatures for detail signatures.
         /showstatistics
         /verbose -->
    <Exec Command="&quot;$(SecAnnotateCommand)&quot; $(_ForceTransparency) /verbose /showstatistics $(_SecAnnotateReferenceDirectory) /out:&quot;$(SecAnnotateOutput)&quot; &quot;$(TargetPath)&quot; >> &quot;$(SecAnnotateLogFile)&quot;"
          WorkingDirectory="$(OutDir)"
          LogStandardErrorAsError="true"
          ContinueOnError="false" />

    <!-- Keep this at the end of the target. -->
    <Touch Files="$(SecAnnotateDummyOutput)" AlwaysCreate="true" />
  </Target>

  <!-- _WarnOnMissingSecAnnotate target. -->
  <Target Name="_WarnOnMissingSecAnnotate">
    <Warning Text="Cannot analyze assemblies for transparency violations. I was unable to locate SecAnnotate.exe. It is part of the Visual Studio installation or the lighter .NET Framework SDK." />
  </Target>

  <!-- ### NuGet packaging ### -->

  <!-- CreateNupkg target. -->
  <Target Name="CreateNupkg"
          Condition=" '$(OutputType)' == 'Library' And '$(NuProjectExists)' == 'true' "
          DependsOnTargets="DeleteNupkgFile;Build;CreateNuspec">
    <!-- NB: Right now, we only enable this target for Library projects. -->
    <Message Text="Creating package for $(AssemblyName)..." Importance="high" />

    <!-- REVIEW: Why can't I quote WorkPackagesDir? -->
    <Exec Command="&quot;$(NuGetCommand)&quot; pack &quot;$(NuspecFile)&quot; -OutputDirectory $(WorkPackagesDir) $(NuGetCommandAdditionalArgs) -NonInteractive -Verbosity quiet"
          LogStandardErrorAsError="true"
          ContinueOnError="false" />
  </Target>

  <!-- CreateNuspec target. -->
  <Target Name="CreateNuspec"
          Condition=" '$(NuProjectExists)' == 'true' "
          DependsOnTargets="DeleteNuspecFile;FindNuGetDependencies;FindProjectDependencies">
    <Message Text="Creating nuspec for $(AssemblyName)..." Importance="normal" />

    <!-- To create a nupkg we need a meaningful version:
         * BuildGeneratedVersion=true, ie the assembly gets an actual version,
           which implies VersionExists = true.
         * the package has a unique version that matchs the assembly version. -->
    <Error Text="You MUST use 'BuildGeneratedVersion=true' to create a NuGet package."
           Condition=" '$(BuildGeneratedVersion)' != 'true' " />

    <!-- The package creation will fail anyway, but better diagnose an invalid configuration before. -->
    <Error Text="You MUST NOT use 'SkipDocumentation=true' when creating a NuGet package."
           Condition=" '$(SkipDocumentation)' == 'true' " />
    <Error Text="You MUST NOT use 'SkipCodeContractsReferenceAssembly=true' when creating a NuGet package."
           Condition=" '$(SkipCodeContractsReferenceAssembly)' == 'true' " />

    <WriteNuspec TemplateFile="$(RepositorySettingsDir)Template.nuspec"
                 OutFile="$(NuspecFile)"

                 Id="$(NuId)"
                 Version="$(NuVersion)"
                 Description="$(NuDescription)"
                 Files="$(NuFiles)"

                 Title="$(NuTitle)"
                 Summary="$(NuSummary)"
                 ReleaseNotes="$(NuReleaseNotes)"
                 Copyright="$(NuCopyright)"
                 Tags="$(NuTags)"
                 Dependencies="$(ProjectDependencies)$(NuGetDependencies)"
                 References="$(NuReferences)" />
  </Target>

  <!-- DeleteNupkgFile target. -->
  <Target Name="DeleteNupkgFile"
          Condition=" '$(NuProjectExists)' == 'true' And '$(Retail)' == 'true' ">
    <!-- No need to try to delete a non-retail packages. Its name changes over time. -->
    <PropertyGroup>
      <_NupkgFile>$(WorkPackagesDir)$(NuId).$(NuVersion).nupkg</_NupkgFile>
    </PropertyGroup>

    <Delete Files="$(_NupkgFile)" />
  </Target>

  <!-- DeleteNuspecFile target. -->
  <Target Name="DeleteNuspecFile" Condition=" '$(NuProjectExists)' == 'true' ">
    <Delete Files="$(NuspecFile)" />
  </Target>

  <!-- FindNuGetDependencies target. -->
  <Target Name="FindNuGetDependencies" Condition=" Exists('$(PackagesConfig)') ">
    <Message Text="Reading packages.config for NuGet dependencies of $(AssemblyName)..." Importance="normal" />

    <ReadDependenciesFromPackagesConfig Config="$(PackagesConfig)">
      <Output TaskParameter="Dependencies" PropertyName="NuGetDependencies"/>
    </ReadDependenciesFromPackagesConfig>
  </Target>

  <!-- FindProjectDependencies target. -->
  <Target Name="FindProjectDependencies" DependsOnTargets="ReadProjectDependency">
    <Message Text="Finding local project dependencies for $(AssemblyName)..." Importance="normal" />

    <PropertyGroup>
      <ProjectDependencies>@(ProjectDependency -> '%(XmlFragment)', '')</ProjectDependencies>
    </PropertyGroup>
  </Target>

  <!-- ReadProjectDependency target. -->
  <Target Name="ReadProjectDependency"
          Condition=" '@(ProjectReference)' != '' "
          Outputs="%(ProjectReference.Identity)">
    <FindProductVersion AssemblyPath="$(OutDir)%(ProjectReference.Name).dll"
                        Retail="$(Retail)">
      <Output TaskParameter="ProductVersion" PropertyName="_ProjectDependencyVersion"/>
    </FindProductVersion>

    <PropertyGroup>
      <_ProjectDependencyId>%(ProjectReference.Name)</_ProjectDependencyId>
    </PropertyGroup>

    <PropertyGroup Condition=" '$(Retail)' != 'true' ">
      <_ProjectDependencyId>$(_ProjectDependencyId).$(EDGE)</_ProjectDependencyId>
      <_ProjectDependencyVersion>(,$(_ProjectDependencyVersion)]</_ProjectDependencyVersion>
    </PropertyGroup>

    <ItemGroup>
      <ProjectDependency Include="$(_ProjectDependencyId)">
        <XmlFragment>
          <![CDATA[
<dependency id="$(_ProjectDependencyId)" version="$(_ProjectDependencyVersion)" />
          ]]>
        </XmlFragment>
      </ProjectDependency>
    </ItemGroup>
  </Target>

  <!-- __InitializeMakeCustomAfterTargets target. -->
  <Target Name="__InitializeMakeCustomAfterTargets" DependsOnTargets="__PatchNuProject" />

  <!-- __PatchNuProject targets. -->
  <Target Name="__PatchNuProject"
          Condition=" '$(NuProjectExists)' == 'true' And '$(Retail)' != 'true' "
          DependsOnTargets="GenerateBuildStamp">
    <!-- For non-retail packages, we change various bits on the fly. -->

    <GetBuildStampAsPreReleaseLabel BuildStamp="$(BuildStamp)">
      <Output TaskParameter="PreReleaseLabel" PropertyName="BuildStampAsPreReleaseLabel"/>
    </GetBuildStampAsPreReleaseLabel>

    <PropertyGroup>
      <EDGE>EDGE</EDGE>

      <NuId>$(NuId).$(EDGE)</NuId>
      <NuTitle Condition=" '$(NuTitle)' != '' ">$(NuTitle) ($(EDGE))</NuTitle>
      <NuVersion>$(MajorVersion).$(MinorVersion).$(PatchVersion)-$(BuildStampAsPreReleaseLabel)</NuVersion>
    </PropertyGroup>
  </Target>
</Project>