<?xml version="1.0" encoding="utf-8" ?>
<Project ToolsVersion="12.0"
         DefaultTargets="Build"
         InitialTargets="__InitializeMakeCommonTargets"
         xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!--
    Prerequisites:
    - @(ProjectsToBuild)
    
    Each master project (e.g. Make.proj) creates its own instance of @(ProjectsToBuild).
    
    Combinations that do not really make sense:
    - No need to set LeanRun to true when targeting LeanBuild.
    - Setting LeanRun will have no effect when targeting CoreBuild.
  -->

  <!-- Import properties if not already done. -->
  <Import Project="$(MSBuildThisFileDirectory)Make.Common.props"
          Condition=" '$(MakeCommonPropsImported)' != 'true' "/>

  <!-- Import common tasks. -->
  <Import Project="$(MSBuildThisFileDirectory)Make.Common.tasks" />

  <!-- Import Xunit tasks. -->
  <Import Project="$(MSBuildThisFileDirectory)Package.Xunit.tasks" />

  <!-- To prevent circular references and to avoid incorrect behaviour, 
       please DO NOT break the following rules:
       - Lean(...) targets MUST NOT refer to Core(...), Clean, Build and Rebuild targets.
       - Core(...) targets MUST NOT refer to Lean(...), Clean, Build and Rebuild targets.
       - Other targets MUST NOT refer to Core(...) and Lean(...) targets,
         instead they should use the Clean, Build and Rebuild targets.
         
       There is only one exception to these rules: CoreBuild depends on the LeanBuild target. -->

  <Target Name="Clean">
    <!-- Artefacts created during a build. -->
    <ItemGroup>
      <_FilesToDelete Include="$(WorkArtefactsDir)\*" />
    </ItemGroup>

    <MSBuild Projects="@(ProjectsToBuild)"
             Properties="$(BuildProperties)"
             BuildInParallel="$(BuildInParallel)"
             Targets="Clean" />

    <Delete Files="@(_FilesToDelete)" />
  </Target>

  <Target Name="Build">
    <PropertyGroup>
      <_TargetsCalledByBuild Condition=" '$(LeanRun)' == 'true' ">LeanBuild</_TargetsCalledByBuild>
      <_TargetsCalledByBuild Condition=" '$(LeanRun)' != 'true' ">CoreBuild</_TargetsCalledByBuild>
    </PropertyGroup>

    <CallTarget Targets="$(_TargetsCalledByBuild)" />
  </Target>

  <Target Name="CoreBuild" DependsOnTargets="RestorePackages;LeanBuild" />

  <Target Name="LeanBuild">
    <!-- WARNING: This target might fail if the packages were not previously 
         restored. We keep it that way to be able to perform fast builds 
         when we know in advance it's OK. Otherwise there is always CoreBuild... -->
    <MSBuild Projects="@(ProjectsToBuild)"
             Properties="$(BuildProperties)"
             BuildInParallel="$(BuildInParallel)"
             Targets="Build"
             StopOnFirstFailure="true">
      <Output ItemName="BuildOutputs" TaskParameter="TargetOutputs" />
    </MSBuild>
  </Target>

  <Target Name="Rebuild">
    <PropertyGroup>
      <_TargetsCalledByRebuild Condition=" '$(LeanRun)' == 'true' ">LeanRebuild</_TargetsCalledByRebuild>
      <_TargetsCalledByRebuild Condition=" '$(LeanRun)' != 'true' ">CoreRebuild</_TargetsCalledByRebuild>
    </PropertyGroup>

    <CallTarget Targets="$(_TargetsCalledByRebuild)" />
  </Target>

  <Target Name="CoreRebuild" DependsOnTargets="_PatchCoreRebuild;Clean;CoreBuild" />

  <Target Name="LeanRebuild">
    <!-- WARNING: See WARNING in LeanBuild. -->
    <MSBuild Projects="@(ProjectsToBuild)"
             Properties="$(BuildProperties)"
             BuildInParallel="$(BuildInParallel)"
             Targets="Rebuild"
             StopOnFirstFailure="true">
      <Output ItemName="BuildOutputs" TaskParameter="TargetOutputs" />
    </MSBuild>
  </Target>

  <Choose>
    <When Condition=" Exists('$(PEVerifyCommand)') ">
      <PropertyGroup>
        <VerifyBuildDependsOn>_PEVerify</VerifyBuildDependsOn>
      </PropertyGroup>
    </When>
    <Otherwise>
      <PropertyGroup>
        <VerifyBuildDependsOn>_WarnOnMissingPEVerify</VerifyBuildDependsOn>
      </PropertyGroup>
    </Otherwise>
  </Choose>

  <Target Name="VerifyBuild" DependsOnTargets="$(VerifyBuildDependsOn)" />

  <Target Name="RunTests"
          DependsOnTargets="Build"
          Inputs="@(BuildOutputs)"
          Outputs="$(XUnitLogFile)">
    <ItemGroup>
      <_TestAssembly Include="%(BuildOutputs.Identity)"
                     Condition=" '@(BuildOutputs->EndsWith('Facts.dll'))' == 'true' " />
    </ItemGroup>

    <!-- Before running XUnit, clean the room. -->
    <Delete Files="$(XUnitLogFile)" Condition=" '@(_TestAssembly)' != '' " />
    
    <!-- Since RunTests depends on Build, we are sure that the directory 
         where reports are stored exists. -->
    <xunit Assemblies="@(_TestAssembly)" Xml="$(XUnitLogFile)" Condition=" '@(_TestAssembly)' != '' " />
  </Target>

  <Target Name="Package" DependsOnTargets="Build">
    <Warning Text="Not yet implemented." />
  </Target>


  <!-- ### Helpers ### -->

  <Target Name="InstallNuGet" Condition=" !Exists('$(NuGetCommand)') ">
    <Message Text="Downloading latest version of NuGet..." Importance="high" />

    <PropertyGroup>
      <_NuGetDir>$([System.IO.Path]::GetDirectoryName($(NuGetCommand)))</_NuGetDir>
    </PropertyGroup>

    <MakeDir Directories="$(_NuGetDir)" Condition=" !Exists($(_NuGetDir)) " />

    <DownloadNuGet OutputFilePath="$(NuGetCommand)" />
  </Target>

  <Target Name="RestorePackages" DependsOnTargets="InstallNuGet">
    <Message Text="Restoring NuGet packages..." Importance="high" />

    <Exec Command="&quot;$(NuGetCommand)&quot; restore &quot;$(SolutionFile)&quot; -PackagesDirectory $(RepositoryRoot)packages -ConfigFile $(RepositoryRoot).nuget\NuGet.Config -NonInteractive -Verbosity quiet"
          LogStandardErrorAsError="true" />
  </Target>


  <!-- ### Private Targets ### -->

  <Target Name="_PatchCoreRebuild">
    <!--
      StyleCop uses $(RebuildDependsOn) to modify the Build process.
      Here, we define Rebuild as Clean;Build, which means that StyleCop
      modifications of the Rebuild process won't apply since we never call
      the Rebuild target of MSBuild.

      The solution is to copy the original StyleCop modifications
      to BuildProperties.

      Another solution is to define our Rebuild target so that it calls MSBuild 
      with the Rebuild target. This is exactly what we do if LeanRun is set to true.
    -->
    <PropertyGroup>
      <BuildProperties>
        $(BuildProperties);
        SourceAnalysisForceFullAnalysis=true
      </BuildProperties>
    </PropertyGroup>
  </Target>

  <!-- PEVerify Targets. -->

  <Target Name="_DeletePEVerifyLog">
    <!-- Before running PEVerify, clean the room. -->
    <Delete Files="$(PEVerifyLogFile)" />
  </Target>

  <Target Name="_PEVerify"
          DependsOnTargets="_DeletePEVerifyLog;Build"
          Inputs="@(BuildOutputs)"
          Outputs="$(PEVerifyDummyOutput)">
    <Message Text="Verifying assemblies with PEVerify..." Importance="high" />

    <Exec Command="&quot;$(PEVerifyCommand)&quot; &quot;%(BuildOutputs.FullPath)&quot; /nologo /md /il /unique >> &quot;$(PEVerifyLogFile)&quot;"
          LogStandardErrorAsError="true"
          ContinueOnError="false" />

    <!-- Keep this at the end of the target, in case one of the PEVerify executions failed. -->
    <Touch Files="$(PEVerifyDummyOutput)" AlwaysCreate="true" />
  </Target>

  <Target Name="_WarnOnMissingPEVerify"
          DependsOnTargets="_DeletePEVerifyLog">
    <Warning Text="Cannot verify assemblies. I was unable to find PEVerify.exe. It is part of the Visual Studio 2013 installation or the lighter .NET Framework SDK."
             ContinueOnError="true" />
  </Target>

  <!-- Initial target. -->
  <Target Name="__InitializeMakeCommonTargets"  Condition=" '$(LeanRun)' != 'true' ">
    <MakeDir Directories="$(WorkRoot)" Condition=" !Exists($(WorkRoot)) " />
    <MakeDir Directories="$(WorkArtefactsDir)" Condition=" !Exists($(WorkArtefactsDir)) " />
  </Target>
</Project>
