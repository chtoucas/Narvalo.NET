// Copyright (c) Narvalo.Org. All rights reserved. See LICENSE.txt in the project root for license information.

namespace Narvalo.T4
{
    using System;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Runtime.Remoting.Messaging;

    using Microsoft.VisualStudio.TextTemplating;

    public abstract class VSTemplate : TextTransformation
    {
        // We use four spaces (no tabs) for indentation.
        private const string INDENT = "    ";

        private readonly Lazy<ITextTemplatingEngineHost> _host;

        private string _name;
        private string _namespace;

        protected VSTemplate()
            : base()
        {
            _host = new Lazy<ITextTemplatingEngineHost>(FindVSHost);
        }

        protected ITextTemplatingEngineHost VSHost
        {
            get { return _host.Value; }
        }

        protected string HeaderText
        {
            get
            {
                var format =
@"// Copyright (c) Narvalo.Org. All rights reserved. See LICENSE.txt in the project root for license information.

//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by a tool. Changes to this file may cause incorrect
// behavior and will be lost if the code is regenerated.
//
// Runtime Version: {0}
// </auto-generated>
//------------------------------------------------------------------------------";

                return String.Format(CultureInfo.InvariantCulture, format, Environment.Version);
            }
        }

        /// <summary>
        /// Gets or sets the name of the monad.
        /// </summary>
        /// <remarks>If no name was specified, it will be infered from the template name.</remarks>
        protected string Name
        {
            get
            {
                if (_name == null)
                {
                    _name = InferName();
                }

                return _name;
            }

            set
            {
                if (_name != null)
                {
                    throw new InvalidOperationException("You can set the name of the monad only once.");
                }

                if (String.IsNullOrWhiteSpace(value))
                {
                    throw new ArgumentException("The name can not be null or blank.");
                }

                _name = value;
            }
        }

        /// <summary>
        /// Gets or sets the name of the namespace.
        /// </summary>
        /// <remarks>If no namespace was specified, it will be infered from the template location.</remarks>
        protected string Namespace
        {
            get
            {
                if (_namespace == null)
                {
                    _namespace = InferNamespace();
                }

                return _namespace;
            }

            set
            {
                if (_namespace != null)
                {
                    throw new InvalidOperationException("You can set the name of the namespace only once.");
                }

                if (String.IsNullOrWhiteSpace(value))
                {
                    throw new ArgumentException("The namespace can not be null or blank.");
                }

                _namespace = value;
            }
        }

        protected static string InferNamespace()
        {
            return CallContext.LogicalGetData("NamespaceHint").ToString();
        }

        protected void PushIndent()
        {
            PushIndent(INDENT);
        }

        protected void WriteNewLine()
        {
            WriteLine(String.Empty);
        }

        protected string InferName()
        {
            return Path.GetFileNameWithoutExtension(VSHost.TemplateFile);
        }

        // TODO: Handle error.
        private ITextTemplatingEngineHost FindVSHost()
        {
            Type transformationType = GetType();
            PropertyInfo pi = transformationType.GetProperty("Host");

            return (ITextTemplatingEngineHost)pi.GetValue(this, null);
        }
    }
}
