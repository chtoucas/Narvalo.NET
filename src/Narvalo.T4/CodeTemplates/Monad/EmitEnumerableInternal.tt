<#+

public partial class MonadTemplate
{
    protected void EmitEnumerableInternal()
    {
#>
    // Provides default implementations for the extension methods for IEnumerable<<#= Name #><T<#= RTDecl #>>>.
    // You will certainly want to shadow them to improve performance.
    // T4: EmitEnumerableInternal().
    internal static partial class EnumerableExtensions
    {
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
        internal static IEnumerable<TSource> CollectAnyImpl<TSource<#= RTDecl #>>(
            this IEnumerable<<#= Name #><TSource<#= RTDecl #>>> source)
        {
            Debug.Assert(source != null);

<#+ if (HasRightGenerics) { #>
            var unit = <#+ WriteFactory("Unit"); #>(Unit.Default);
<#+ } #>
            var item = default(TSource);

            using (var iter = source.GetEnumerator())
            {
                while (iter.MoveNext())
                {
                    bool append = false;
                    var current = iter.Current;

<#+ if (IsNullable) { #>
                    if (current == null) { continue; }
<#+ } #>

                    current.Bind(val =>
                    {
                        append = true;
                        item = val;

<#+ if (HasRightGenerics) { #>
                        return unit;
<#+ } else { #>
                        return <#= Name #>.Unit;
<#+ } #>
                    });

                    if (append) { yield return item; }
                }
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
        internal static <#= Name #><IEnumerable<TSource><#= RTDecl #>> CollectImpl<TSource<#= RTDecl #>>(
            this IEnumerable<<#= Name #><TSource<#= RTDecl #>>> source)
        {
            Debug.Assert(source != null);
            return <#+ WriteFactory("IEnumerable<TSource>"); #>(CollectAnyImpl(source));
        }
<#+ if (HasSum) { #>

        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
        internal static <#= Name #><TSource> SumImpl<TSource>(
            this IEnumerable<<#= Name #><TSource>> source)
        {
            Debug.Assert(source != null);
            return source.Aggregate(<#= Name #><TSource>.<#= ZeroName #>, (m, n) => m.<#= PlusName #>(n));
        }
<#+ } // T4: End of HasSum. #>
    }
<#+
    } // T4: End of EmitEnumerableInternal().
} // T4: End of MonadTemplate.

#>