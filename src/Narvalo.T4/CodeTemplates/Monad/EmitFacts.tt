<#+

public partial class MonadTemplate
{
    public void EmitFacts()
    {
#>
namespace <#= Namespace #>
{
    using System;

    using Xunit;

    public static partial class <#= Name #>Facts
    {
        #region Linq Operators

        [Fact]
        public static void Select_ThrowsArgumentNullException_ForNullSelector()
        {
            // Arrange
            var source = <#= Name #>.<#= ReturnName #>(1);
            Func<int, int> selector = null;

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => source.Select(selector));
        }

<#+ if (HasFilter) { #>

        [Fact]
        public static void Where_ThrowsArgumentNullException_ForNullPredicate()
        {
            // Arrange
            var source = <#= Name #>.<#= ReturnName #>(1);
            Func<int, bool> predicate = null;

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => source.Where(predicate));
        }

<#+ } // T4: End of HasFilter. #>

        [Fact]
        public static void SelectMany_ThrowsArgumentNullException_ForNullValueSelector()
        {
            // Arrange
            var source = <#= Name #>.<#= ReturnName #>(1);
            Func<int, <#= Name #><int>> valueSelector = null;
            Func<int, int, int> resultSelector = (i, j) => i + j;

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => source.SelectMany(valueSelector, resultSelector));
        }

        [Fact]
        public static void SelectMany_ThrowsArgumentNullException_ForNullResultSelector()
        {
            // Arrange
            var source = <#= Name #>.<#= ReturnName #>(1);
            var middle = <#= Name #>.<#= ReturnName #>(2);
            Func<int, <#= Name #><int>> valueSelector = _ => middle;
            Func<int, int, int> resultSelector = null;

            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => source.SelectMany(valueSelector, resultSelector));
        }

        #endregion

        #region Monad Laws

<#+ if (HasZero && HasPlus) { #>

        [Fact]
        public static void <#= Name #>_SatisfiesFirstMonoidLaw()
        {
            // Arrange
            var monad = <#= Name #>.<#= ReturnName #>(1);

            // Act
            var left = <#= Name #><int>.<#= ZeroName #>.<#= PlusName #>(monad);
            var right = monad;

            // Assert
            Assert.True(left.Equals(right));
        }

        [Fact]
        public static void <#= Name #>_SatisfiesSecondMonoidLaw()
        {
            // Arrange
            var monad = <#= Name #>.<#= ReturnName #>(1);

            // Act
            var left = monad.<#= PlusName #>(<#= Name #><int>.<#= ZeroName #>);
            var right = monad;

            // Assert
            Assert.True(left.Equals(right));
        }

        [Fact]
        public static void <#= Name #>_SatisfiesThirdMonoidLaw()
        {
            // Arrange
            var monadA = <#= Name #>.<#= ReturnName #>(1);
            var monadB = <#= Name #>.<#= ReturnName #>(2);
            var monadC = <#= Name #>.<#= ReturnName #>(3);

            // Act
            var left = monadA.<#= PlusName #>(monadB.<#= PlusName #>(monadC));
            var right = monadA.<#= PlusName #>(monadB).<#= PlusName #>(monadC);

            // Assert
            Assert.True(left.Equals(right));
        }

<#+ } // T4: End of HasZero && HasPlus. #>

        [Fact]
        public static void <#= Name #>_SatisfiesFirstMonadLaw()
        {
            // Arrange
            int value = 1;
            Func<int, <#= Name #><long>> kun = _ => <#= Name #>.<#= ReturnName #>((long)2 * _);

            // Act
            var left = <#= Name #>.<#= ReturnName #>(value).Bind(kun);
            var right = kun(value);

            // Assert
            Assert.True(left.Equals(right));
        }

        [Fact]
        public static void <#= Name #>_SatisfiesSecondMonadLaw()
        {
            // Arrange
            Func<int, <#= Name #><int>> create = _ => <#= Name #>.<#= ReturnName #>(_);
            var monad = <#= Name #>.<#= ReturnName #>(1);

            // Act
            var left = monad.Bind(create);
            var right = monad;

            // Assert
            Assert.True(left.Equals(right));
        }

        [Fact]
        public static void <#= Name #>_SatisfiesThirdMonadLaw()
        {
            // Arrange
            <#= Name #><short> m = <#= Name #>.<#= ReturnName #>((short)1);
            Func<short, <#= Name #><int>> f = _ => <#= Name #>.<#= ReturnName #>((int)3 * _);
            Func<int, <#= Name #><long>> g = _ => <#= Name #>.<#= ReturnName #>((long)2 * _);

            // Act
            var left = m.Bind(f).Bind(g);
            var right = m.Bind(_ => f(_).Bind(g));

            // Assert
            Assert.True(left.Equals(right));
        }

<#+ if (HasZero) { #>

        [Fact]
        public static void <#= Name #>_SatisfiesMonadZeroRule()
        {
            // Arrange
            Func<int, <#= Name #><long>> kun = _ => <#= Name #>.<#= ReturnName #>((long)2 * _);

            // Act
            var left = <#= Name #><int>.<#= ZeroName #>.Bind(kun);
            var right = <#= Name #><long>.<#= ZeroName #>;

            // Assert
            Assert.True(left.Equals(right));
        }

        [Fact]
        public static void <#= Name #>_SatisfiesMonadMoreRule()
        {
            // Act
            var leftSome = <#= Name #>.<#= ReturnName #>(1).Bind(_ => <#= Name #><int>.<#= ZeroName #>);
            var leftNone = <#= Name #><int>.<#= ZeroName #>.Bind(_ => <#= Name #><int>.<#= ZeroName #>);
            var right = <#= Name #><int>.<#= ZeroName #>;

            // Assert
            Assert.True(leftSome.Equals(right));
            Assert.True(leftNone.Equals(right));
        }

<#+ } // T4: End of HasZero. #>

<#+ if (HasZero && HasPlus) { #>

        [Fact]
        public static void <#= Name #>_SatisfiesMonadOrRule()
        {
            // Arrange
            var monad = <#= Name #>.<#= ReturnName #>(2);

            // Act
            var leftSome = monad.<#= PlusName #>(<#= Name #>.<#= ReturnName #>(1));
            var leftNone = monad.<#= PlusName #>(<#= Name #><int>.<#= ZeroName #>);
            var right = monad;

            // Assert
            Assert.True(leftSome.Equals(right));
            Assert.True(leftNone.Equals(right));
        }

        [Fact]
        public static void <#= Name #>_DoesNotSatisfyRightZeroForPlus()
        {
            // Arrange
            var monad = <#= Name #>.<#= ReturnName #>(2);

            // Act
            var leftSome = <#= Name #>.<#= ReturnName #>(1).<#= PlusName #>(monad);
            var leftNone = <#= Name #><int>.<#= ZeroName #>.<#= PlusName #>(monad);
            var right = monad;

            // Assert
            Assert.False(leftSome.Equals(right));   // NB: Fails here the "Unit is a right zero for Plus".
            Assert.True(leftNone.Equals(right));
        }

<#+ } // T4: End of HasZero && HasPlus. #>

        #endregion
    } // End of <#= Name #> - T4: EmitFacts().
} // End of <#= Namespace #>.
<#+
    } // T4: End of EmitFacts().
} // T4: End of MonadTemplate.

#>