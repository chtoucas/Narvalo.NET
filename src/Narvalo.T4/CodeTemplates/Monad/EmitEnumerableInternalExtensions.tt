<#+

public partial class MonadTemplate
{
    protected void EmitEnumerableInternalExtensions()
    {
        // Normally we would name the class with EnumerableExtensions, but we prefer
        // Enumerable{Name}Extensions to avoid any method collision.
        // Indeed if we generate two monads in the same namespace, we might end up
        // with two methods named the same in the same partial class.
#>
    // Provides the core extension methods for IEnumerable<T>.
    internal static partial class EnumerableExtensions
    {

<#+ if (!HasTypeConstraints) { #>

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><IEnumerable<TResult>> ForEachCore<TSource, TResult>(
            this IEnumerable<TSource> @this,
            Func<TSource, <#= Name #><TResult>> funM)
        {
            Demand.NotNull(@this);
            Demand.NotNull(funM);
<#+ if (IsNullable) { #>
            Warrant.NotNull<<#= Name #><IEnumerable<TResult>>>();
<#+ } #>

            return @this.Select(funM).EmptyIfNull().Collect();
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><IEnumerable<TSource>> WhereCore<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, <#= Name #><bool>> predicateM)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(predicateM, nameof(predicateM));
            Warrant.NotNull<IEnumerable<TSource>>();

            throw new NotImplementedException();

            /*
            // NB: Haskell uses tail recursion, we don't.
            var list = new List<TSource>();

            foreach (var item in @this)
            {
                var m = predicateM.Invoke(item);

<#+ if (IsNullable) { #>
                if (m != null)
                {
                    m.Trigger(
                        _ =>
                        {
                            if (_ == true)
                            {
                                list.Add(item);
                            }
                        });
                }
<#+ } else { #>
                m.Trigger(
                    _ =>
                    {
                        if (_ == true)
                        {
                            list.Add(item);
                        }
                    });
<#+ } // T4: End of IsNullable. #>
            }

            return list;
            */
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><Tuple<IEnumerable<TFirst>, IEnumerable<TSecond>>>
            SelectAndUnzipCore<TSource, TFirst, TSecond>(
            this IEnumerable<TSource> @this,
            Func<TSource, <#= Name #><Tuple<TFirst, TSecond>>> funM)
        {
            Demand.NotNull(@this);
            Demand.NotNull(funM);
<#+ if (PostMapEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><Tuple<IEnumerable<TFirst>, IEnumerable<TSecond>>>>();
<#+ } #>

            var m = @this.Select(funM).EmptyIfNull().Collect();

            return m.<#= MapName #>(
                tuples =>
                {
                    IEnumerable<TFirst> list1 = tuples.Select(_ => _.Item1);
                    IEnumerable<TSecond> list2 = tuples.Select(_ => _.Item2);

                    return new Tuple<IEnumerable<TFirst>, IEnumerable<TSecond>>(list1, list2);
                });
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><IEnumerable<TResult>> ZipCore<TFirst, TSecond, TResult>(
            this IEnumerable<TFirst> @this,
            IEnumerable<TSecond> second,
            Func<TFirst, TSecond, <#= Name #><TResult>> resultSelectorM)
        {
            Require.NotNull(resultSelectorM, nameof(resultSelectorM));

            Demand.NotNull(@this);
            Demand.NotNull(second);
<#+ if (IsNullable) { #>
            Warrant.NotNull<<#= Name #><IEnumerable<TResult>>>();
<#+ } #>

            Func<TFirst, TSecond, <#= Name #><TResult>> resultSelector
                = (v1, v2) => resultSelectorM.Invoke(v1, v2);

            // WARNING: Do not remove "resultSelector", otherwise .NET will make a recursive call
            // instead of using the Zip from LINQ.
            IEnumerable<<#= Name #><TResult>> seq = @this.Zip(second, resultSelector: resultSelector);

            return seq.EmptyIfNull().Collect();
        }

<#+ } // T4: End of !HasTypeConstraints. #>

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TAccumulate> FoldCore<TSource, TAccumulate>(
            this IEnumerable<TSource> @this,
            TAccumulate seed,
            Func<TAccumulate, TSource, <#= Name #><TAccumulate>> accumulatorM)
            <#+ WriteTypeConstraints("TSource", "TAccumulate"); #>
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulatorM, nameof(accumulatorM));
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TAccumulate>>();
<#+ } #>

            <#= Name #><TAccumulate> retval = <#= Name #>.<#= ReturnName #>(seed);

            foreach (TSource item in @this)
            {
<#+ if (IsNullable && !HasZero) { #>
                if (retval == null)
                {
                    return null;
                }

<#+ } #>
                retval = retval.Bind(_ => accumulatorM.Invoke(_, item));
            }

            return retval;
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TAccumulate> FoldBackCore<TSource, TAccumulate>(
            this IEnumerable<TSource> @this,
            TAccumulate seed,
            Func<TAccumulate, TSource, <#= Name #><TAccumulate>> accumulatorM)
            <#+ WriteTypeConstraints("TSource", "TAccumulate"); #>
        {
            Demand.NotNull(@this);
            Demand.NotNull(accumulatorM);
<#+ // "Fold" can not guarantee non null return value. #>
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TAccumulate>>();
<#+ } #>

            return @this.Reverse().EmptyIfNull().Fold(seed, accumulatorM);
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TSource> ReduceCore<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, TSource, <#= Name #><TSource>> accumulatorM)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulatorM, nameof(accumulatorM));
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TSource>>();
<#+ } #>

            using (var iter = @this.GetEnumerator())
            {
                if (!iter.MoveNext())
                {
                    throw new InvalidOperationException("Source sequence was empty.");
                }

                <#= Name #><TSource> retval = <#= Name #>.<#= ReturnName #>(iter.Current);

                while (iter.MoveNext())
                {
<#+ if (IsNullable && !HasZero) { #>
                    if (retval == null)
                    {
                        return null;
                    }

<#+ } #>
                    retval = retval.Bind(_ => accumulatorM.Invoke(_, iter.Current));
                }

                return retval;
            }
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TSource> ReduceBackCore<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, TSource, <#= Name #><TSource>> accumulatorM)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            Demand.NotNull(@this);
            Demand.NotNull(accumulatorM);
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TSource>>();
<#+ } #>

            return @this.Reverse().EmptyIfNull().Reduce(accumulatorM);
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TAccumulate> FoldCore<TSource, TAccumulate>(
            this IEnumerable<TSource> @this,
            TAccumulate seed,
            Func<TAccumulate, TSource, <#= Name #><TAccumulate>> accumulatorM,
            Func<<#= Name #><TAccumulate>, bool> predicate)
            <#+ WriteTypeConstraints("TSource", "TAccumulate"); #>
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulatorM, nameof(accumulatorM));
            Require.NotNull(predicate, nameof(predicate));
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TAccumulate>>();
<#+ } #>

            <#= Name #><TAccumulate> retval = <#= Name #>.<#= ReturnName #>(seed);

            using (var iter = @this.GetEnumerator())
            {
                while (predicate.Invoke(retval) && iter.MoveNext())
                {
<#+ if (IsNullable && !HasZero) { #>
                    if (retval == null)
                    {
                        return null;
                    }

<#+ } #>
                    retval = retval.Bind(_ => accumulatorM.Invoke(_, iter.Current));
                }
            }

            return retval;
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TSource> ReduceCore<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, TSource, <#= Name #><TSource>> accumulatorM,
            Func<<#= Name #><TSource>, bool> predicate)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulatorM, nameof(accumulatorM));
            Require.NotNull(predicate, nameof(predicate));
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TSource>>();
<#+ } #>

            using (var iter = @this.GetEnumerator())
            {
                if (!iter.MoveNext())
                {
                    throw new InvalidOperationException("Source sequence was empty.");
                }

                <#= Name #><TSource> retval = <#= Name #>.<#= ReturnName #>(iter.Current);

                while (predicate.Invoke(retval) && iter.MoveNext())
                {
<#+ if (IsNullable && !HasZero) { #>
                    if (retval == null)
                    {
                        return null;
                    }

<#+ } #>
                    retval = retval.Bind(_ => accumulatorM.Invoke(_, iter.Current));
                }

                return retval;
            }
        }
    } // End of EnumerableExtensions - T4: EmitEnumerableInternalExtensions().
<#+
    } // T4: End of EmitEnumerableInternalExtensions().
} // T4: End of MonadTemplate.

#>