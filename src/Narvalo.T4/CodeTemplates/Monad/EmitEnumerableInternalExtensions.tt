<#+

public partial class MonadTemplate
{
    protected void EmitEnumerableInternalExtensions()
    {
#>
    // Provides default implementations for the extension methods for IEnumerable<T>.
    // You will certainly want to override them to improve performance.
    internal static partial class EnumerableExtensions
    {
<#+ if (!HasTypeConstraints) { #>
<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><IEnumerable<TResult>> SelectWithImpl<TSource, TResult>(
            this IEnumerable<TSource> @this,
            Func<TSource, <#= Name #><TResult>> selector)
        {
            Demand.NotNull(@this);
            Demand.NotNull(selector);

            return @this.Select(selector).Collect();
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><IEnumerable<TSource>> WhereByImpl<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, <#= Name #><bool>> predicate)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(predicate, nameof(predicate));

            Func<TSource, Func<bool, IEnumerable<TSource>, IEnumerable<TSource>>> func
                = item => (flg, seq) => flg ? seq.Append(item) : seq;

            Func<<#= Name #><IEnumerable<TSource>>, TSource, <#= Name #><IEnumerable<TSource>>> accumulator
                = (mseq, item) => predicate(item).Zip(mseq, func(item));

            return @this.Aggregate(<#= Name #>.<#= ReturnName #>(Enumerable.Empty<TSource>()), accumulator);
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><Tuple<IEnumerable<TFirst>, IEnumerable<TSecond>>>
            SelectUnzipImpl<TSource, TFirst, TSecond>(
            this IEnumerable<TSource> @this,
            Func<TSource, <#= Name #><Tuple<TFirst, TSecond>>> selector)
        {
            Demand.NotNull(@this);
            Demand.NotNull(selector);

            return @this.SelectWith(selector).<#= MapName #>(
                tuples =>
                {
                    var seq1 = tuples.Select(_ => _.Item1);
                    var seq2 = tuples.Select(_ => _.Item2);

                    return new Tuple<IEnumerable<TFirst>, IEnumerable<TSecond>>(seq1, seq2);
                });
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><IEnumerable<TResult>> ZipWithImpl<TFirst, TSecond, TResult>(
            this IEnumerable<TFirst> @this,
            IEnumerable<TSecond> second,
            Func<TFirst, TSecond, <#= Name #><TResult>> resultSelector)
        {
            Demand.NotNull(resultSelector);
            Demand.NotNull(@this);
            Demand.NotNull(second);

            return @this.Zip(second, resultSelector).Collect();
        }

<#+ } // T4: End of !HasTypeConstraints. #>

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TAccumulate> FoldImpl<TSource, TAccumulate>(
            this IEnumerable<TSource> @this,
            TAccumulate seed,
            Func<TAccumulate, TSource, <#= Name #><TAccumulate>> accumulator)
            <#+ WriteTypeConstraints("TSource", "TAccumulate"); #>
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulator, nameof(accumulator));

            Func<<#= Name #><TAccumulate>, TSource, <#= Name #><TAccumulate>> func
                = (arg1, arg2) => arg1.Bind(arg => accumulator(arg, arg2));

            return @this.Aggregate(<#+ WriteFactory("TAccumulate"); #>(seed), func);
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TAccumulate> FoldBackImpl<TSource, TAccumulate>(
            this IEnumerable<TSource> @this,
            TAccumulate seed,
            Func<TAccumulate, TSource, <#= Name #><TAccumulate>> accumulator)
            <#+ WriteTypeConstraints("TSource", "TAccumulate"); #>
        {
            Demand.NotNull(@this);
            Demand.NotNull(accumulator);

            return @this.Reverse().Fold(seed, accumulator);
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TSource> ReduceImpl<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, TSource, <#= Name #><TSource>> accumulator)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulator, nameof(accumulator));

            using (var iter = @this.GetEnumerator())
            {
                if (!iter.MoveNext())
                {
                    throw new InvalidOperationException("Source sequence was empty.");
                }

                <#= Name #><TSource> retval = <#= Name #>.<#= ReturnName #>(iter.Current);

                while (iter.MoveNext())
                {
<#+ if (IsNullable && !HasZero) { #>
                    if (retval == null)
                    {
                        return null;
                    }

<#+ } #>
                    retval = retval.Bind(_ => accumulator.Invoke(_, iter.Current));
                }

                return retval;
            }
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TSource> ReduceBackImpl<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, TSource, <#= Name #><TSource>> accumulator)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            Demand.NotNull(@this);
            Demand.NotNull(accumulator);

            return @this.Reverse().Reduce(accumulator);
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TAccumulate> FoldImpl<TSource, TAccumulate>(
            this IEnumerable<TSource> @this,
            TAccumulate seed,
            Func<TAccumulate, TSource, <#= Name #><TAccumulate>> accumulator,
            Func<<#= Name #><TAccumulate>, bool> predicate)
            <#+ WriteTypeConstraints("TSource", "TAccumulate"); #>
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulator, nameof(accumulator));
            Require.NotNull(predicate, nameof(predicate));

            <#= Name #><TAccumulate> retval = <#= Name #>.<#= ReturnName #>(seed);

            using (var iter = @this.GetEnumerator())
            {
                while (predicate.Invoke(retval) && iter.MoveNext())
                {
<#+ if (IsNullable && !HasZero) { #>
                    if (retval == null)
                    {
                        return null;
                    }

<#+ } #>
                    retval = retval.Bind(_ => accumulator.Invoke(_, iter.Current));
                }
            }

            return retval;
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TSource> ReduceImpl<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, TSource, <#= Name #><TSource>> accumulator,
            Func<<#= Name #><TSource>, bool> predicate)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulator, nameof(accumulator));
            Require.NotNull(predicate, nameof(predicate));

            using (var iter = @this.GetEnumerator())
            {
                if (!iter.MoveNext())
                {
                    throw new InvalidOperationException("Source sequence was empty.");
                }

                <#= Name #><TSource> retval = <#= Name #>.<#= ReturnName #>(iter.Current);

                while (predicate.Invoke(retval) && iter.MoveNext())
                {
<#+ if (IsNullable && !HasZero) { #>
                    if (retval == null)
                    {
                        return null;
                    }

<#+ } #>
                    retval = retval.Bind(_ => accumulator.Invoke(_, iter.Current));
                }

                return retval;
            }
        }
    } // End of EnumerableExtensions - T4: EmitEnumerableInternalExtensions().
<#+
    } // T4: End of EmitEnumerableInternalExtensions().
} // T4: End of MonadTemplate.

#>