<#+

public partial class MonadTemplate
{
    protected void EmitEnumerableInternalExtensions()
    {
#>
    // Provides default implementations for the extension methods for IEnumerable<T>.
    // You will certainly want to override them to improve performance.
    internal static partial class EnumerableExtensions
    {

<#+ if (!HasTypeConstraints) { #>

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><IEnumerable<TResult>> MapImpl<TSource, TResult>(
            this IEnumerable<TSource> @this,
            Func<TSource, <#= Name #><TResult>> selector)
        {
            Demand.NotNull(@this);
            Demand.NotNull(selector);
<#+ if (IsNullable) { #>
            Warrant.NotNull<<#= Name #><IEnumerable<TResult>>>();
<#+ } #>

            return @this.Select(selector).EmptyIfNull().Collect();
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><IEnumerable<TSource>> FilterImpl<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, <#= Name #><bool>> predicate)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(predicate, nameof(predicate));
            Warrant.NotNull<IEnumerable<TSource>>();

            Func<bool, IEnumerable<TSource>, TSource, IEnumerable<TSource>> selector
                = (flg, list, item) => { if (flg) { return list.Prepend(item); } else { return list; } };

            Func<<#= Name #><IEnumerable<TSource>>, TSource, <#= Name #><IEnumerable<TSource>>> accumulator
                = (mlist, item) => predicate.Invoke(item).Zip(mlist, (flg, list) => selector.Invoke(flg, list, item));

            var seed = <#= Name #>.<#= ReturnName #>(Enumerable.Empty<TSource>());

            // REVIEW: Aggregate?
            return @this.AggregateBack(seed, accumulator);
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><Tuple<IEnumerable<TFirst>, IEnumerable<TSecond>>>
            MapUnzipImpl<TSource, TFirst, TSecond>(
            this IEnumerable<TSource> @this,
            Func<TSource, <#= Name #><Tuple<TFirst, TSecond>>> selector)
        {
            Demand.NotNull(@this);
            Demand.NotNull(selector);
<#+ if (PostMapEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><Tuple<IEnumerable<TFirst>, IEnumerable<TSecond>>>>();
<#+ } #>

            return @this.Map(selector).<#= MapName #>(
                tuples =>
                {
                    IEnumerable<TFirst> list1 = tuples.Select(_ => _.Item1);
                    IEnumerable<TSecond> list2 = tuples.Select(_ => _.Item2);

                    return new Tuple<IEnumerable<TFirst>, IEnumerable<TSecond>>(list1, list2);
                });
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><IEnumerable<TResult>> ZipWithImpl<TFirst, TSecond, TResult>(
            this IEnumerable<TFirst> @this,
            IEnumerable<TSecond> second,
            Func<TFirst, TSecond, <#= Name #><TResult>> resultSelector)
        {
            Require.NotNull(resultSelector, nameof(resultSelector));

            Demand.NotNull(@this);
            Demand.NotNull(second);
<#+ if (IsNullable) { #>
            Warrant.NotNull<<#= Name #><IEnumerable<TResult>>>();
<#+ } #>

            Func<TFirst, TSecond, <#= Name #><TResult>> selector
                = (v1, v2) => resultSelector.Invoke(v1, v2);

            IEnumerable<<#= Name #><TResult>> seq = @this.Zip(second, selector);

            return seq.EmptyIfNull().Collect();
        }

<#+ } // T4: End of !HasTypeConstraints. #>

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TAccumulate> FoldImpl<TSource, TAccumulate>(
            this IEnumerable<TSource> @this,
            TAccumulate seed,
            Func<TAccumulate, TSource, <#= Name #><TAccumulate>> accumulator)
            <#+ WriteTypeConstraints("TSource", "TAccumulate"); #>
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulator, nameof(accumulator));
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TAccumulate>>();
<#+ } #>

            <#= Name #><TAccumulate> retval = <#= Name #>.<#= ReturnName #>(seed);

            foreach (TSource item in @this)
            {
<#+ if (IsNullable && !HasZero) { #>
                if (retval == null)
                {
                    return null;
                }

<#+ } #>
                retval = retval.Bind(_ => accumulator.Invoke(_, item));
            }

            return retval;
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TAccumulate> FoldBackImpl<TSource, TAccumulate>(
            this IEnumerable<TSource> @this,
            TAccumulate seed,
            Func<TAccumulate, TSource, <#= Name #><TAccumulate>> accumulator)
            <#+ WriteTypeConstraints("TSource", "TAccumulate"); #>
        {
            Demand.NotNull(@this);
            Demand.NotNull(accumulator);
<#+ // "Fold" can not guarantee non null return value. #>
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TAccumulate>>();
<#+ } #>

            return @this.Reverse().EmptyIfNull().Fold(seed, accumulator);
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TSource> ReduceImpl<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, TSource, <#= Name #><TSource>> accumulator)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulator, nameof(accumulator));
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TSource>>();
<#+ } #>

            using (var iter = @this.GetEnumerator())
            {
                if (!iter.MoveNext())
                {
                    throw new InvalidOperationException("Source sequence was empty.");
                }

                <#= Name #><TSource> retval = <#= Name #>.<#= ReturnName #>(iter.Current);

                while (iter.MoveNext())
                {
<#+ if (IsNullable && !HasZero) { #>
                    if (retval == null)
                    {
                        return null;
                    }

<#+ } #>
                    retval = retval.Bind(_ => accumulator.Invoke(_, iter.Current));
                }

                return retval;
            }
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TSource> ReduceBackImpl<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, TSource, <#= Name #><TSource>> accumulator)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            Demand.NotNull(@this);
            Demand.NotNull(accumulator);
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TSource>>();
<#+ } #>

            return @this.Reverse().EmptyIfNull().Reduce(accumulator);
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TAccumulate> FoldImpl<TSource, TAccumulate>(
            this IEnumerable<TSource> @this,
            TAccumulate seed,
            Func<TAccumulate, TSource, <#= Name #><TAccumulate>> accumulator,
            Func<<#= Name #><TAccumulate>, bool> predicate)
            <#+ WriteTypeConstraints("TSource", "TAccumulate"); #>
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulator, nameof(accumulator));
            Require.NotNull(predicate, nameof(predicate));
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TAccumulate>>();
<#+ } #>

            <#= Name #><TAccumulate> retval = <#= Name #>.<#= ReturnName #>(seed);

            using (var iter = @this.GetEnumerator())
            {
                while (predicate.Invoke(retval) && iter.MoveNext())
                {
<#+ if (IsNullable && !HasZero) { #>
                    if (retval == null)
                    {
                        return null;
                    }

<#+ } #>
                    retval = retval.Bind(_ => accumulator.Invoke(_, iter.Current));
                }
            }

            return retval;
        }

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TSource> ReduceImpl<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, TSource, <#= Name #><TSource>> accumulator,
            Func<<#= Name #><TSource>, bool> predicate)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulator, nameof(accumulator));
            Require.NotNull(predicate, nameof(predicate));
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TSource>>();
<#+ } #>

            using (var iter = @this.GetEnumerator())
            {
                if (!iter.MoveNext())
                {
                    throw new InvalidOperationException("Source sequence was empty.");
                }

                <#= Name #><TSource> retval = <#= Name #>.<#= ReturnName #>(iter.Current);

                while (predicate.Invoke(retval) && iter.MoveNext())
                {
<#+ if (IsNullable && !HasZero) { #>
                    if (retval == null)
                    {
                        return null;
                    }

<#+ } #>
                    retval = retval.Bind(_ => accumulator.Invoke(_, iter.Current));
                }

                return retval;
            }
        }
    } // End of EnumerableExtensions - T4: EmitEnumerableInternalExtensions().
<#+
    } // T4: End of EmitEnumerableInternalExtensions().
} // T4: End of MonadTemplate.

#>