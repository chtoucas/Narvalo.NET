<#+

public partial class MonadTemplate
{
    protected void EmitEnumerableExtensions()
    {
#>
    // Provides static methods to operate on IEnumerable<<#= Name #><T<#= RTDecl #>>>.
    // These are not extension methods like any LINQ operator, because they are not composable.
    // T4: EmitEnumerableExtensions().
    public <#= HelpersTypeDecl #> <#= Name #>
    {
        public static <#= Name #><IEnumerable<T><#= RTDecl #>> Collect<T<#= RTDecl #>>(
            IEnumerable<<#= Name #><T<#= RTDecl #>>> source)
        {
            <#+ WriteNotNull("source", true); #>
            return source.CollectImpl();
        }

        public static <#= Name #><IEnumerable<T><#= RTDecl #>> Filter<T<#= RTDecl #>>(
            IEnumerable<T> source,
            Func<T, <#= Name #><bool<#= RTDecl #>>> predicate)
        {
            <#+ WriteNotNull("source", true); #>
            Require.NotNull(predicate, nameof(predicate));
            return source.WhereImpl(predicate);
        }

        public static <#= Name #><IEnumerable<TResult><#= RTDecl #>> Map<T, TResult<#= RTDecl #>>(
            IEnumerable<T> source,
            Func<T, <#= Name #><TResult<#= RTDecl #>>> selector)
            => <#= Name #>.Collect(source.Select(selector));

        public static <#= Name #><IEnumerable<TResult><#= RTDecl #>> Zip<T1, T2, TResult<#= RTDecl #>>(
            IEnumerable<T1> first,
            IEnumerable<T2> second,
            Func<T1, T2, <#= Name #><TResult<#= RTDecl #>>> resultSelector)
            => <#= Name #>.Collect(first.Zip(second, resultSelector));
    }
<#+
    } // T4: End of EmitEnumerableExtensions().
} // T4: End of MonadTemplate.

#>