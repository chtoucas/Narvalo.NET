<#+

public partial class MonadTemplate
{
    protected void EmitEnumerableExtensions()
    {
#>
    // Provides extension methods for IEnumerable<T>.
    // We do not use the standard LINQ names to avoid a confusing API (see ZipWithCore()).
    // - Select    -> Map
    // - Where     -> Filter
    // - Zip       -> ZipWith
    // - Aggregate -> Reduce or Fold
    public static partial class EnumerableExtensions
    {
        #region Basic Monad functions (Prelude)

<#+ if (!HasTypeConstraints) { #>

        /// <remarks>Named <c>mapM</c> in Haskell parlance.</remarks>
        public static <#= Name #><IEnumerable<TResult>> Map<TSource, TResult>(
            this IEnumerable<TSource> @this,
            Func<TSource, <#= Name #><TResult>> selectorM)
        {
            Expect.NotNull(@this);
            Expect.NotNull(selectorM);
<#+ if (IsNullable) { #>
            Warrant.NotNull<<#= Name #><IEnumerable<TResult>>>();
<#+ } #>

            return @this.MapCore(selectorM);
        }

<#+ } // T4: End of !HasTypeConstraints. #>

        #endregion

        #region Generalisations of list functions (Prelude)

<#+ if (!HasTypeConstraints) { #>

        /// <remarks>Named <c>filterM</c> in Haskell parlance.</remarks>
        public static <#= Name #><IEnumerable<TSource>> Filter<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, <#= Name #><bool>> predicateM)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            Expect.NotNull(@this);
            Expect.NotNull(predicateM);
            Warrant.NotNull<IEnumerable<TSource>>();

            return @this.FilterCore(predicateM);
        }

        /// <remarks>
        /// Named <c>mapAndUnzipM</c> in Haskell parlance.
        /// </remarks>
        public static <#= Name #><Tuple<IEnumerable<TFirst>, IEnumerable<TSecond>>>
            MapUnzip<TSource, TFirst, TSecond>(
            this IEnumerable<TSource> @this,
            Func<TSource, <#= Name #><Tuple<TFirst, TSecond>>> funM)
        {
            Expect.NotNull(@this);
            Expect.NotNull(funM);
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><Tuple<IEnumerable<TFirst>, IEnumerable<TSecond>>>>();
<#+ } #>

            return @this.MapUnzipCore(funM);
        }

        /// <remarks>
        /// Named <c>zipWithM</c> in Haskell parlance.
        /// </remarks>
        public static <#= Name #><IEnumerable<TResult>> ZipWith<TFirst, TSecond, TResult>(
            this IEnumerable<TFirst> @this,
            IEnumerable<TSecond> second,
            Func<TFirst, TSecond, <#= Name #><TResult>> resultSelectorM)
        {
            Expect.NotNull(@this);
            Expect.NotNull(second);
            Expect.NotNull(resultSelectorM);
<#+ if (IsNullable) { #>
            Warrant.NotNull<<#= Name #><IEnumerable<TResult>>>();
<#+ } #>

            return @this.ZipWithCore(second, resultSelectorM);
        }

<#+ } // T4: End of !HasTypeConstraints. #>

        /// <remarks>
        /// Named <c>foldM</c> in Haskell parlance.
        /// </remarks>
        public static <#= Name #><TAccumulate> Fold<TSource, TAccumulate>(
            this IEnumerable<TSource> @this,
            TAccumulate seed,
            Func<TAccumulate, TSource, <#= Name #><TAccumulate>> accumulatorM)
            <#+ WriteTypeConstraints("TSource", "TAccumulate"); #>
        {
            Expect.NotNull(@this);
            Expect.NotNull(accumulatorM);
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TAccumulate>>();
<#+ } #>

            return @this.FoldCore(seed, accumulatorM);
        }

        #endregion

        #region Aggregate Operators

        public static <#= Name #><TAccumulate> FoldBack<TSource, TAccumulate>(
            this IEnumerable<TSource> @this,
            TAccumulate seed,
            Func<TAccumulate, TSource, <#= Name #><TAccumulate>> accumulatorM)
            <#+ WriteTypeConstraints("TSource", "TAccumulate"); #>
        {
            Expect.NotNull(@this);
            Expect.NotNull(accumulatorM);
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TAccumulate>>();
<#+ } #>

            return @this.FoldBackCore(seed, accumulatorM);
        }

        public static <#= Name #><TSource> Reduce<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, TSource, <#= Name #><TSource>> accumulatorM)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            Expect.NotNull(@this);
            Expect.NotNull(accumulatorM);
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TSource>>();
<#+ } #>

            return @this.ReduceCore(accumulatorM);
        }

        public static <#= Name #><TSource> ReduceBack<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, TSource, <#= Name #><TSource>> accumulatorM)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            Expect.NotNull(@this);
            Expect.NotNull(accumulatorM);
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TSource>>();
<#+ } #>

            return @this.ReduceBackCore(accumulatorM);
        }

        #endregion

        #region Catamorphisms

        /// <remarks>
        /// <para>Haskell use a different signature.</para>
        /// </remarks>
        public static <#= Name #><TAccumulate> Fold<TSource, TAccumulate>(
            this IEnumerable<TSource> @this,
            TAccumulate seed,
            Func<TAccumulate, TSource, <#= Name #><TAccumulate>> accumulatorM,
            Func<<#= Name #><TAccumulate>, bool> predicate)
            <#+ WriteTypeConstraints("TSource", "TAccumulate"); #>
        {
            Expect.NotNull(@this);
            Expect.NotNull(accumulatorM);
            Expect.NotNull(predicate);
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TAccumulate>>();
<#+ } #>

            return @this.FoldCore(seed, accumulatorM, predicate);
        }

        /// <remarks>
        /// <para>Haskell use a different signature.</para>
        /// </remarks>
        public static <#= Name #><TSource> Reduce<TSource>(
            this IEnumerable<TSource> @this,
            Func<TSource, TSource, <#= Name #><TSource>> accumulatorM,
            Func<<#= Name #><TSource>, bool> predicate)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            Expect.NotNull(@this);
            Expect.NotNull(accumulatorM);
            Expect.NotNull(predicate);
<#+ if (IsNullable && HasZero) { #>
            Warrant.NotNull<<#= Name #><TSource>>();
<#+ } #>

            return @this.ReduceCore(accumulatorM, predicate);
        }

        #endregion
    } // End of EnumerableExtensions - T4: EmitEnumerableExtensions().
<#+
    } // T4: End of EmitEnumerableExtensions().
} // T4: End of MonadTemplate.

#>
