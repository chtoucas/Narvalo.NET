<#+

public partial class MonadTemplate
{
    protected void EmitMonadExtensions()
    {
#>
    // Provides the core monadic extension methods for <#= Name #><T<#= SuffixT #>>.
    public static partial class <#= Name #>
    {
        #region Applicative

        // Named "<$" (Applicative) in Haskell parlance.
        public static <#= Name #><TResult<#= SuffixT #>> Replace<TSource, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            TResult value)
            <#+ WriteTypeConstraints("TSource", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
<#+ if (PostMapEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult<#= SuffixT #>>>();
<#+ } #>

            return @this.Select(_ => value);
        }

<#+ if (!HasTypeConstraints) { #>

        public static <#= Name #><Tuple<TSource, TOther><#= SuffixT #>> Zip<TSource, TOther<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            <#= Name #><TOther<#= SuffixT #>> other)
            <#+ WriteTypeConstraints("TSource", "TOther"); #>
        {
            <#+ WriteNotNull(); #>

            return @this.Zip(other, Tuple.Create);
        }

<#+ } // T4: End of !HasTypeConstraints. #>

        #endregion

        #region Basic Monad functions

        // Named "fmap", "liftA" or "<$>" (Applicative) in Haskell parlance.
        public static <#= Name #><TResult<#= SuffixT #>> <#= MapName #><TSource, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, TResult> selector)
            <#+ WriteTypeConstraints("TSource", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            Require.NotNull(selector, nameof(selector));
<#+ if (PostBindEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult<#= SuffixT #>>>();
<#+ } #>

            return @this.Bind(_ => <#+ WriteFactory("TResult"); #>(selector.Invoke(_)));
        }

        // Named ">>" (Monad) or "*>" (Applicative) in Haskell parlance.
        public static <#= Name #><TResult<#= SuffixT #>> ContinueWith<TSource, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            <#= Name #><TResult<#= SuffixT #>> other)
            <#+ WriteTypeConstraints("TSource", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
<#+ if (PostBindEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult<#= SuffixT #>>>();
<#+ } #>

            return @this.Bind(_ => other);
        }

        // Named "void" in Haskell parlance.
<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Usage", "CA1801:ReviewUnusedParameters", MessageId = "this", Justification = "[Intentionally] This method always returns the same result.")]
<#+ } #>
        public static <#= Name #><global::Narvalo.Fx.Unit<#= SuffixT #>> Skip<TSource<#= SuffixT #>>(this <#= Name #><TSource<#= SuffixT #>> @this)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(); #>
<#+ if (IsNullable) { #>
            Warrant.NotNull<<#= Name #><global::Narvalo.Fx.Unit<#= SuffixT #>>>();
<#+ } #>
<#+ WriteLine(); #>

<#+ if (HasSuffixT) { #>
            return <#+ WriteFactory("Unit"); #>(global::Narvalo.Fx.Unit.Single);
<#+ } else { #>
            return <#= Name #>.Unit;
<#+ } #>
        }

        #endregion

        #region Generalisations of list functions

<#+ if (HasZero) { #>

        // Named "mfilter" in Haskell parlance.
        public static <#= Name #><TSource<#= SuffixT #>> <#= FilterName #><TSource<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, bool> predicate)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(); #>
            Require.NotNull(predicate, nameof(predicate));
<#+ if (PostBindEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TSource<#= SuffixT #>>>();
<#+ } #>

            return @this.Bind(
                _ => predicate.Invoke(_) ? @this : <#= Name #><TSource<#= SuffixT #>>.<#= ZeroName #>);
        }

<#+ } // T4: End of HasZero. #>

<#+ if (!HasTypeConstraints) { #>

        // Named "replicateM" in Haskell parlance.
        public static <#= Name #><IEnumerable<TSource><#= SuffixT #>> Repeat<TSource<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            int count)
        {
            <#+ WriteNotNull(); #>
            Require.Range(count >= 1, nameof(count));
<#+ if (PostMapEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><IEnumerable<TSource><#= SuffixT #>>>();
<#+ } #>

            return @this.<#= MapName #>(_ => Enumerable.Repeat(_, count));
        }

<#+ } // T4: End of !HasTypeConstraints. #>

        #endregion

        #region Applicative lifting operators

        /// <see cref="Lift{T1, T2, T3}" />
        // Named "liftA2" (Applicative) in Haskell parlance.
        public static <#= Name #><TResult<#= SuffixT #>> Zip<TFirst, TSecond, TResult<#= SuffixT #>>(
            this <#= Name #><TFirst<#= SuffixT #>> @this,
            <#= Name #><TSecond<#= SuffixT #>> second,
            Func<TFirst, TSecond, TResult> resultSelector)
            <#+ WriteTypeConstraints("TFirst", "TSecond", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            <#+ WriteNotNull("second"); #>
            Require.NotNull(resultSelector, nameof(resultSelector));
<#+ if (PostBindEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult<#= SuffixT #>>>();
<#+ } #>

            return @this.Bind(v1 => second.<#= MapName #>(v2 => resultSelector.Invoke(v1, v2)));
        }

        /// <see cref="Lift{T1, T2, T3, T4}" />
        // Named "liftA3" (Applicative) in Haskell parlance.
        public static <#= Name #><TResult<#= SuffixT #>> Zip<T1, T2, T3, TResult<#= SuffixT #>>(
            this <#= Name #><T1<#= SuffixT #>> @this,
            <#= Name #><T2<#= SuffixT #>> second,
            <#= Name #><T3<#= SuffixT #>> third,
            Func<T1, T2, T3, TResult> resultSelector)
            <#+ WriteTypeConstraints("T1", "T2", "T3", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            <#+ WriteNotNull("second"); #>
            Require.NotNull(resultSelector, nameof(resultSelector));
<#+ if (PostBindEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult<#= SuffixT #>>>();
<#+ } #>

            Func<T1, <#= Name #><TResult<#= SuffixT #>>> g
                = t1 => second.Zip(third, (t2, t3) => resultSelector.Invoke(t1, t2, t3));

            return @this.Bind(g);
        }

        /// <see cref="Lift{T1, T2, T3, T4, T5}" />
        // Named "liftA4" (Applicative) in Haskell parlance.
        public static <#= Name #><TResult<#= SuffixT #>> Zip<T1, T2, T3, T4, TResult<#= SuffixT #>>(
             this <#= Name #><T1<#= SuffixT #>> @this,
             <#= Name #><T2<#= SuffixT #>> second,
             <#= Name #><T3<#= SuffixT #>> third,
             <#= Name #><T4<#= SuffixT #>> fourth,
             Func<T1, T2, T3, T4, TResult> resultSelector)
            <#+ WriteTypeConstraints("T1", "T2", "T3", "T4", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            <#+ WriteNotNull("second"); #>
            Require.NotNull(resultSelector, nameof(resultSelector));
<#+ if (PostBindEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult<#= SuffixT #>>>();
<#+ } #>

            Func<T1, <#= Name #><TResult<#= SuffixT #>>> g
                = t1 => second.Zip(
                    third,
                    fourth,
                    (t2, t3, t4) => resultSelector.Invoke(t1, t2, t3, t4));

            return @this.Bind(g);
        }

        /// <see cref="Lift{T1, T2, T3, T4, T5, T6}" />
        // Named "liftA5" (Applicative) in Haskell parlance.
        public static <#= Name #><TResult<#= SuffixT #>> Zip<T1, T2, T3, T4, T5, TResult<#= SuffixT #>>(
            this <#= Name #><T1<#= SuffixT #>> @this,
            <#= Name #><T2<#= SuffixT #>> second,
            <#= Name #><T3<#= SuffixT #>> third,
            <#= Name #><T4<#= SuffixT #>> fourth,
            <#= Name #><T5<#= SuffixT #>> fifth,
            Func<T1, T2, T3, T4, T5, TResult> resultSelector)
            <#+ WriteTypeConstraints("T1", "T2", "T3", "T4", "T5", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            <#+ WriteNotNull("second"); #>
            Require.NotNull(resultSelector, nameof(resultSelector));
<#+ if (PostBindEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult<#= SuffixT #>>>();
<#+ } #>

            Func<T1, <#= Name #><TResult<#= SuffixT #>>> g
                = t1 => second.Zip(
                    third,
                    fourth,
                    fifth,
                    (t2, t3, t4, t5) => resultSelector.Invoke(t1, t2, t3, t4, t5));

            return @this.Bind(g);
        }

        #endregion

        #region Query Expression Pattern

<#+ if (!PreferLinqDialect) { #>

<#+ if (HasFilter) { #>

        public static <#= Name #><TSource<#= SuffixT #>> Where<TSource<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, bool> predicate)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(); #>
<#+ if (PostFilterEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TSource<#= SuffixT #>>>();
<#+ } #>

            return @this.<#= FilterName #>(predicate);
        }

<#+ } // T4: End of HasFilter. #>

        public static <#= Name #><TResult> Select<TSource, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, TResult> selector)
            <#+ WriteTypeConstraints("TSource", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
<#+ if (PostMapEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult<#= SuffixT #>>>();
<#+ } #>

            return @this.<#= MapName #>(selector);
        }

<#+ } // T4: End of !PreferLinqDialect. #>

        /// <remarks>
        /// Kind of generalisation of <see cref="Zip{T1, T2, T3}" />.
        /// </remarks>
        public static <#= Name #><TResult<#= SuffixT #>> SelectMany<TSource, TMiddle, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, <#= Name #><TMiddle<#= SuffixT #>>> valueSelector,
            Func<TSource, TMiddle, TResult> resultSelector)
            <#+ WriteTypeConstraints("TSource", "TMiddle", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            Require.NotNull(valueSelector, nameof(valueSelector));
            Require.NotNull(resultSelector, nameof(resultSelector));
<#+ if (PostBindEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult<#= SuffixT #>>>();
<#+ } #>

            return @this.Bind(
                _ => valueSelector.Invoke(_).<#= MapName #>(
                    middle => resultSelector.Invoke(_, middle)));
        }

<#+ if (HasJoin) { #>

        public static <#= Name #><TResult> Join<TSource, TInner, TKey, TResult>(
            this <#= Name #><TSource> @this,
            <#= Name #><TInner> inner,
            Func<TSource, TKey> outerKeySelector,
            Func<TInner, TKey> innerKeySelector,
            Func<TSource, TInner, TResult> resultSelector)
            <#+ WriteTypeConstraints("TSource", "TInner", "TKey", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
<#+ if (IsNullable) { #>
            Expect.NotNull(inner);
<#+ } #>
            Expect.NotNull(outerKeySelector);
            Expect.NotNull(innerKeySelector);
            Expect.NotNull(resultSelector);
<#+ if (PostJoinEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult>>();
<#+ } #>

            return JoinImpl(
                @this,
                inner,
                outerKeySelector,
                innerKeySelector,
                resultSelector,
                EqualityComparer<TKey>.Default);
        }

        public static <#= Name #><TResult> GroupJoin<TSource, TInner, TKey, TResult>(
            this <#= Name #><TSource> @this,
            <#= Name #><TInner> inner,
            Func<TSource, TKey> outerKeySelector,
            Func<TInner, TKey> innerKeySelector,
            Func<TSource, <#= Name #><TInner>, TResult> resultSelector)
            <#+ WriteTypeConstraints("TSource", "TInner", "TKey", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
<#+ if (IsNullable) { #>
            Expect.NotNull(inner);
<#+ } #>
            Expect.NotNull(outerKeySelector);
            Expect.NotNull(innerKeySelector);
            Expect.NotNull(resultSelector);
<#+ if (PostGroupJoinEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult>>();
<#+ } #>

            return GroupJoinImpl(
                @this,
                inner,
                outerKeySelector,
                innerKeySelector,
                resultSelector,
                EqualityComparer<TKey>.Default);
        }

<#+ } // T4: End of HasJoin. #>

        #endregion

        #region LINQ extensions

<#+ if (HasJoin) { #>

        public static <#= Name #><TResult> Join<TSource, TInner, TKey, TResult>(
            this <#= Name #><TSource> @this,
            <#= Name #><TInner> inner,
            Func<TSource, TKey> outerKeySelector,
            Func<TInner, TKey> innerKeySelector,
            Func<TSource, TInner, TResult> resultSelector,
            IEqualityComparer<TKey> comparer)
            <#+ WriteTypeConstraints("TSource", "TInner", "TKey", "TResult"); #>
        {
<#+ if (IsNullable) { #>
            Expect.NotNull(@this);
            Expect.NotNull(inner);
<#+ } #>
            Expect.NotNull(outerKeySelector);
            Expect.NotNull(innerKeySelector);
            Expect.NotNull(resultSelector);
<#+ if (PostJoinEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult>>();
<#+ } #>

            return JoinImpl(
                @this,
                inner,
                outerKeySelector,
                innerKeySelector,
                resultSelector,
                comparer ?? EqualityComparer<TKey>.Default);
        }

        public static <#= Name #><TResult> GroupJoin<TSource, TInner, TKey, TResult>(
            this <#= Name #><TSource> @this,
            <#= Name #><TInner> inner,
            Func<TSource, TKey> outerKeySelector,
            Func<TInner, TKey> innerKeySelector,
            Func<TSource, <#= Name #><TInner>, TResult> resultSelector,
            IEqualityComparer<TKey> comparer)
            <#+ WriteTypeConstraints("TSource", "TInner", "TKey", "TResult"); #>
        {
<#+ if (IsNullable) { #>
            Expect.NotNull(@this);
            Expect.NotNull(inner);
<#+ } #>
            Expect.NotNull(outerKeySelector);
            Expect.NotNull(innerKeySelector);
            Expect.NotNull(resultSelector);
<#+ if (PostGroupJoinEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult>>();
<#+ } #>

            return GroupJoinImpl(
                @this,
                inner,
                outerKeySelector,
                innerKeySelector,
                resultSelector,
                comparer ?? EqualityComparer<TKey>.Default);
        }


        private static <#= Name #><TResult> JoinImpl<TSource, TInner, TKey, TResult>(
            <#= Name #><TSource> seq,
            <#= Name #><TInner> inner,
            Func<TSource, TKey> outerKeySelector,
            Func<TInner, TKey> innerKeySelector,
            Func<TSource, TInner, TResult> resultSelector,
            IEqualityComparer<TKey> comparer)
            <#+ WriteTypeConstraints("TSource", "TInner", "TKey", "TResult"); #>
        {
            <#+ WriteNotNull("seq"); #>
            Require.NotNull(resultSelector, nameof(resultSelector));
<#+ if (IsNullable) { #>
            Demand.NotNull(inner);
<#+ } #>
            Demand.NotNull(outerKeySelector);
            Demand.NotNull(innerKeySelector);
            Demand.NotNull(comparer);
<#+ if (PostMapEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult>>();
<#+ } #>

            var keyLookupM = GetKeyLookup(inner, outerKeySelector, innerKeySelector, comparer);

            return from outerValue in seq
                   from innerValue in keyLookupM.Invoke(outerValue).ContinueWith(inner)
                   select resultSelector.Invoke(outerValue, innerValue);
        }

        private static <#= Name #><TResult> GroupJoinImpl<TSource, TInner, TKey, TResult>(
            <#= Name #><TSource> seq,
            <#= Name #><TInner> inner,
            Func<TSource, TKey> outerKeySelector,
            Func<TInner, TKey> innerKeySelector,
            Func<TSource, <#= Name #><TInner>, TResult> resultSelector,
            IEqualityComparer<TKey> comparer)
            <#+ WriteTypeConstraints("TSource", "TInner", "TKey", "TResult"); #>
        {
            <#+ WriteNotNull("seq"); #>
            Require.NotNull(resultSelector, nameof(resultSelector));
<#+ if (IsNullable) { #>
            Demand.NotNull(inner);
<#+ } #>
            Demand.NotNull(outerKeySelector);
            Demand.NotNull(innerKeySelector);
            Demand.NotNull(comparer);
<#+ if (PostMapEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult>>();
<#+ } #>

            var keyLookupM = GetKeyLookup(inner, outerKeySelector, innerKeySelector, comparer);

            return from outerValue in seq
                   select resultSelector.Invoke(outerValue, keyLookupM.Invoke(outerValue).ContinueWith(inner));
        }

        private static Func<TSource, <#= Name #><TKey>> GetKeyLookup<TSource, TInner, TKey>(
            <#= Name #><TInner> inner,
            Func<TSource, TKey> outerKeySelector,
            Func<TInner, TKey> innerKeySelector,
            IEqualityComparer<TKey> comparer)
            <#+ WriteTypeConstraints("TSource", "TInner", "TKey"); #>
        {
            <#+ WriteNotNull("inner"); #>
            Require.NotNull(outerKeySelector, nameof(outerKeySelector));
            Require.NotNull(comparer, nameof(comparer));
            Demand.NotNull(innerKeySelector);
            Warrant.NotNull<Func<TSource, <#= Name #><TKey>>>();

            return source =>
            {
                TKey outerKey = outerKeySelector.Invoke(source);

                return inner.<#= MapName #>(innerKeySelector).<#= FilterName #>(_ => comparer.Equals(_, outerKey));
            };
        }

<#+ } // T4: End of HasJoin. #>

        #endregion
    } // End of <#= Name #> - T4: EmitMonadExtensions().
<#+
    } // T4: End of EmitMonadExtensions().
} // T4: End of MonadTemplate.

#>