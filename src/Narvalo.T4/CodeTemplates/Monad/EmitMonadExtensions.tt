<#+

public partial class MonadTemplate
{
    protected void EmitMonadExtensions()
    {
#>
    // Provides extension methods for <#= Name #><T<#= SuffixT #>>.
    public static partial class <#= Name #>
    {
<#+ if (!HasTypeConstraints) { #>
        /// <seealso cref="Apply{TSource, TResult<#= SuffixT #>}" />
        public static <#= Name #><TResult<#= SuffixT #>> Gather<TSource, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            <#= Name #><Func<TSource, TResult><#= SuffixT #>> applicative)
        {
            <#+ WriteNotNull(); #>
            <#+ WriteNotNull("applicative"); #>
            return applicative.Bind(func => @this.Select(func));
        }

        /// <seealso cref="Gather{TSource, TResult<#= SuffixT #>}" />
        public static <#= Name #><TResult<#= SuffixT #>> Apply<TSource, TResult<#= SuffixT #>>(
            this <#= Name #><Func<TSource, TResult><#= SuffixT #>> @this,
            <#= Name #><TSource<#= SuffixT #>> value)
        {
            <#+ WriteNotNull("value"); #>
            return value.Gather(@this);
        }

        public static <#= Name #><IEnumerable<TSource><#= SuffixT #>> Repeat<TSource<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            int count)
        {
            <#+ WriteNotNull(); #>
            Require.Range(count >= 1, nameof(count));
            return @this.<#= MapName #>(val => Enumerable.Repeat(val, count));
        }
<#+ } // T4: End of !HasTypeConstraints. #>

        public static <#= Name #><TResult<#= SuffixT #>> ReplaceBy<TSource, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            TResult value)
            <#+ WriteTypeConstraints("TSource", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            return @this.Select(_ => value);
        }

        public static <#= Name #><TResult<#= SuffixT #>> Then<TSource, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            <#= Name #><TResult<#= SuffixT #>> other)
            <#+ WriteTypeConstraints("TSource", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            return @this.Bind(_ => other);
        }

        public static <#= Name #><TSource<#= SuffixT #>> Ignore<TSource, TOther<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            <#= Name #><TOther<#= SuffixT #>> other)
            <#+ WriteTypeConstraints("TSource", "TOther"); #>
        {
            <#+ WriteNotNull(); #>
            Func<TSource, TOther, TSource> ignore = (arg, _) => arg;

            return @this.Zip(other, ignore);
        }

        public static <#= Name #><global::Narvalo.Fx.Unit<#= SuffixT #>> Skip<TSource<#= SuffixT #>>(this <#= Name #><TSource<#= SuffixT #>> @this)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(); #>

<#+ if (HasSuffixT) { #>
            return @this.ReplaceBy(global::Narvalo.Fx.Unit.Default);
<#+ } else { #>
            return @this.Then(Unit);
<#+ } #>
        }
<#+ if (HasZero) { #>

        public static <#= Name #><TResult> If<TSource, TResult>(
            this <#= Name #><TSource> @this,
            Func<TSource, bool> predicate,
            <#= Name #><TResult> thenResult)
            <#+ WriteTypeConstraints("TSource", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            Require.NotNull(predicate, nameof(predicate));
            return @this.Bind(val => predicate(val) ? thenResult : <#= Name #><TResult>.<#= ZeroName #>);
        }
<#+ } // T4: End of HasZero. #>

        public static <#= Name #><TResult<#= SuffixT #>> Coalesce<TSource, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, bool> predicate,
            <#= Name #><TResult<#= SuffixT #>> thenResult,
            <#= Name #><TResult<#= SuffixT #>> elseResult)
            <#+ WriteTypeConstraints("TSource", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            Require.NotNull(predicate, nameof(predicate));
            return @this.Bind(val => predicate(val) ? thenResult : elseResult);
        }

        public static <#= Name #><TResult<#= SuffixT #>> Using<TSource, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, <#= Name #><TResult<#= SuffixT #>>> selector)
            <#+ WriteCustomTypeConstraint("TSource", "IDisposable"); #>
            <#+ WriteTypeConstraints("TResult"); #>
        {
            <#+ WriteNotNull(); #>
            Require.NotNull(selector, nameof(selector));
            return @this.Bind(val => { using (val) { return selector(val); } });
        }

        public static <#= Name #><TResult<#= SuffixT #>> Using<TSource, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, TResult> selector)
            <#+ WriteCustomTypeConstraint("TSource", "IDisposable"); #>
            <#+ WriteTypeConstraints("TResult"); #>
        {
            <#+ WriteNotNull(); #>
            Require.NotNull(selector, nameof(selector));
            return @this.<#= MapName #>(val => { using (val) { return selector(val); } });
        }

        #region Zip()
<#+ if (!HasTypeConstraints) { #>

        public static <#= Name #><Tuple<TSource, TOther><#= SuffixT #>> Zip<TSource, TOther<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            <#= Name #><TOther<#= SuffixT #>> other)
            <#+ WriteTypeConstraints("TSource", "TOther"); #>
        {
            <#+ WriteNotNull(); #>
            return @this.Zip(other, Tuple.Create);
        }
<#+ } #>

        /// <seealso cref="Lift{TFirst, TSecond, TResult<#= SuffixT #>}" />
        public static <#= Name #><TResult<#= SuffixT #>> Zip<TFirst, TSecond, TResult<#= SuffixT #>>(
            this <#= Name #><TFirst<#= SuffixT #>> @this,
            <#= Name #><TSecond<#= SuffixT #>> second,
            Func<TFirst, TSecond, TResult> zipper)
            <#+ WriteTypeConstraints("TFirst", "TSecond", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            <#+ WriteNotNull("second"); #>
            Require.NotNull(zipper, nameof(zipper));

<#+ if (HasTypeConstraints) { #>
            return @this.Bind(
                arg1 => second.Select(
                    arg2 => zipper(arg1, arg2)));
<#+ } else { #>
            Func<TFirst, Func<TSecond, TResult>> selector
                = arg1 => arg2 => zipper(arg1, arg2);

            return second.Gather(
                @this.Select(selector));
<#+ } #>
        }

        /// <seealso cref="Lift{T1, T2, T3, TResult<#= SuffixT #>}" />
        public static <#= Name #><TResult<#= SuffixT #>> Zip<T1, T2, T3, TResult<#= SuffixT #>>(
            this <#= Name #><T1<#= SuffixT #>> @this,
            <#= Name #><T2<#= SuffixT #>> second,
            <#= Name #><T3<#= SuffixT #>> third,
            Func<T1, T2, T3, TResult> zipper)
            <#+ WriteTypeConstraints("T1", "T2", "T3", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            <#+ WriteNotNull("second"); #>
            <#+ WriteNotNull("third"); #>
            Require.NotNull(zipper, nameof(zipper));

<#+ if (HasTypeConstraints) { #>
            return @this.Bind(
                arg1 => second.Bind(
                    arg2 => third.Select(
                        arg3 => zipper(arg1, arg2, arg3))));
<#+ } else { #>
            Func<T1, Func<T2, Func<T3, TResult>>> selector
                = arg1 => arg2 => arg3 => zipper(arg1, arg2, arg3);

            return third.Gather(
                second.Gather(
                    @this.Select(selector)));
<#+ } #>
        }

        /// <seealso cref="Lift{T1, T2, T3, T4, TResult<#= SuffixT #>}" />
        public static <#= Name #><TResult<#= SuffixT #>> Zip<T1, T2, T3, T4, TResult<#= SuffixT #>>(
             this <#= Name #><T1<#= SuffixT #>> @this,
             <#= Name #><T2<#= SuffixT #>> second,
             <#= Name #><T3<#= SuffixT #>> third,
             <#= Name #><T4<#= SuffixT #>> fourth,
             Func<T1, T2, T3, T4, TResult> zipper)
            <#+ WriteTypeConstraints("T1", "T2", "T3", "T4", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            <#+ WriteNotNull("second"); #>
            <#+ WriteNotNull("third"); #>
            <#+ WriteNotNull("fourth"); #>
            Require.NotNull(zipper, nameof(zipper));

<#+ if (HasTypeConstraints) { #>
            return @this.Bind(
                arg1 => second.Bind(
                    arg2 => third.Bind(
                        arg3 => fourth.Select(
                            arg4 => zipper(arg1, arg2, arg3, arg4)))));
<#+ } else { #>
            Func<T1, Func<T2, Func<T3, Func<T4, TResult>>>> selector
                = arg1 => arg2 => arg3 => arg4 => zipper(arg1, arg2, arg3, arg4);

            return fourth.Gather(
                third.Gather(
                    second.Gather(
                        @this.Select(selector))));
<#+ } #>
        }

        /// <seealso cref="Lift{T1, T2, T3, T4, T5, TResult<#= SuffixT #>}" />
        public static <#= Name #><TResult<#= SuffixT #>> Zip<T1, T2, T3, T4, T5, TResult<#= SuffixT #>>(
            this <#= Name #><T1<#= SuffixT #>> @this,
            <#= Name #><T2<#= SuffixT #>> second,
            <#= Name #><T3<#= SuffixT #>> third,
            <#= Name #><T4<#= SuffixT #>> fourth,
            <#= Name #><T5<#= SuffixT #>> fifth,
            Func<T1, T2, T3, T4, T5, TResult> zipper)
            <#+ WriteTypeConstraints("T1", "T2", "T3", "T4", "T5", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            <#+ WriteNotNull("second"); #>
            <#+ WriteNotNull("third"); #>
            <#+ WriteNotNull("fourth"); #>
            <#+ WriteNotNull("fifth"); #>
            Require.NotNull(zipper, nameof(zipper));

<#+ if (HasTypeConstraints) { #>
            return @this.Bind(
                arg1 => second.Bind(
                    arg2 => third.Bind(
                        arg3 => fourth.Bind(
                            arg4 => fifth.Select(
                                arg5 => zipper(arg1, arg2, arg3, arg4, arg5))))));
<#+ } else { #>
            Func<T1, Func<T2, Func<T3, Func<T4, Func<T5, TResult>>>>> selector
                = arg1 => arg2 => arg3 => arg4 => arg5 => zipper(arg1, arg2, arg3, arg4, arg5);

            return fifth.Gather(
                fourth.Gather(
                    third.Gather(
                        second.Gather(
                            @this.Select(selector)))));
<#+ } #>
        }

        #endregion

        #region LINQ dialect

        public static <#= Name #><TResult<#= SuffixT #>> <#= MapName #><TSource, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, TResult> selector)
            <#+ WriteTypeConstraints("TSource", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            Require.NotNull(selector, nameof(selector));
            return @this.Bind(val => <#+ WriteFactory("TResult"); #>(selector(val)));
        }
<#+ if (HasZero) { #>

        public static <#= Name #><TSource<#= SuffixT #>> <#= FilterName #><TSource<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, bool> predicate)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(); #>
            Require.NotNull(predicate, nameof(predicate));
            return @this.Bind(val => predicate(val) ? <#+ WriteFactory("TSource"); #>(val) : <#= Name #><TSource<#= SuffixT #>>.<#= ZeroName #>);
        }
<#+ } // T4: End of HasZero. #>
<#+ if (!PreferLinqDialect) { #>
<#+ if (HasFilter) { #>
        public static <#= Name #><TSource<#= SuffixT #>> Where<TSource<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, bool> predicate)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(); #>

            return @this.<#= FilterName #>(predicate);
        }
<#+ } // T4: End of HasFilter. #>

        public static <#= Name #><TResult> Select<TSource, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, TResult> selector)
            <#+ WriteTypeConstraints("TSource", "TResult"); #>
        {
            <#+ WriteNotNull(); #>

            return @this.<#= MapName #>(selector);
        }
<#+ } // T4: End of !PreferLinqDialect. #>

        /// <remarks>
        /// Kind of generalisation of <see cref="Zip{T1, T2, T3}" />.
        /// </remarks>
        public static <#= Name #><TResult<#= SuffixT #>> SelectMany<TSource, TMiddle, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, <#= Name #><TMiddle<#= SuffixT #>>> valueSelector,
            Func<TSource, TMiddle, TResult> resultSelector)
            <#+ WriteTypeConstraints("TSource", "TMiddle", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            Require.NotNull(valueSelector, nameof(valueSelector));
            Require.NotNull(resultSelector, nameof(resultSelector));

            return @this.Bind(
                val => valueSelector(val).<#= MapName #>(
                    middle => resultSelector(val, middle)));
        }
<#+ if (HasJoin) { #>

        public static <#= Name #><TResult> Join<TSource, TInner, TKey, TResult>(
            this <#= Name #><TSource> @this,
            <#= Name #><TInner> inner,
            Func<TSource, TKey> outerKeySelector,
            Func<TInner, TKey> innerKeySelector,
            Func<TSource, TInner, TResult> resultSelector)
            <#+ WriteTypeConstraints("TSource", "TInner", "TKey", "TResult"); #>
            => JoinImpl(
                @this,
                inner,
                outerKeySelector,
                innerKeySelector,
                resultSelector,
                EqualityComparer<TKey>.Default);

        public static <#= Name #><TResult> Join<TSource, TInner, TKey, TResult>(
            this <#= Name #><TSource> @this,
            <#= Name #><TInner> inner,
            Func<TSource, TKey> outerKeySelector,
            Func<TInner, TKey> innerKeySelector,
            Func<TSource, TInner, TResult> resultSelector,
            IEqualityComparer<TKey> comparer)
            <#+ WriteTypeConstraints("TSource", "TInner", "TKey", "TResult"); #>
            => JoinImpl(
                @this,
                inner,
                outerKeySelector,
                innerKeySelector,
                resultSelector,
                comparer ?? EqualityComparer<TKey>.Default);

        public static <#= Name #><TResult> GroupJoin<TSource, TInner, TKey, TResult>(
            this <#= Name #><TSource> @this,
            <#= Name #><TInner> inner,
            Func<TSource, TKey> outerKeySelector,
            Func<TInner, TKey> innerKeySelector,
            Func<TSource, <#= Name #><TInner>, TResult> resultSelector)
            <#+ WriteTypeConstraints("TSource", "TInner", "TKey", "TResult"); #>
            => GroupJoinImpl(
                @this,
                inner,
                outerKeySelector,
                innerKeySelector,
                resultSelector,
                EqualityComparer<TKey>.Default);

        public static <#= Name #><TResult> GroupJoin<TSource, TInner, TKey, TResult>(
            this <#= Name #><TSource> @this,
            <#= Name #><TInner> inner,
            Func<TSource, TKey> outerKeySelector,
            Func<TInner, TKey> innerKeySelector,
            Func<TSource, <#= Name #><TInner>, TResult> resultSelector,
            IEqualityComparer<TKey> comparer)
            <#+ WriteTypeConstraints("TSource", "TInner", "TKey", "TResult"); #>
            => GroupJoinImpl(
                @this,
                inner,
                outerKeySelector,
                innerKeySelector,
                resultSelector,
                comparer ?? EqualityComparer<TKey>.Default);

        private static <#= Name #><TResult> JoinImpl<TSource, TInner, TKey, TResult>(
            <#= Name #><TSource> outer,
            <#= Name #><TInner> inner,
            Func<TSource, TKey> outerKeySelector,
            Func<TInner, TKey> innerKeySelector,
            Func<TSource, TInner, TResult> resultSelector,
            IEqualityComparer<TKey> comparer)
            <#+ WriteTypeConstraints("TSource", "TInner", "TKey", "TResult"); #>
        {
            <#+ WriteNotNull("outer"); #>
            <#+ WriteNotNull("inner"); #>
            Require.NotNull(resultSelector, nameof(resultSelector));
            Require.NotNull(outerKeySelector, nameof(outerKeySelector));
            Require.NotNull(innerKeySelector, nameof(innerKeySelector));
            Require.NotNull(comparer, nameof(comparer));

            var keyLookup = GetKeyLookup(inner, outerKeySelector, innerKeySelector, comparer);

            return outer.SelectMany(val => keyLookup(val).Then(inner), resultSelector);
        }

        private static <#= Name #><TResult> GroupJoinImpl<TSource, TInner, TKey, TResult>(
            <#= Name #><TSource> outer,
            <#= Name #><TInner> inner,
            Func<TSource, TKey> outerKeySelector,
            Func<TInner, TKey> innerKeySelector,
            Func<TSource, <#= Name #><TInner>, TResult> resultSelector,
            IEqualityComparer<TKey> comparer)
            <#+ WriteTypeConstraints("TSource", "TInner", "TKey", "TResult"); #>
        {
            <#+ WriteNotNull("outer"); #>
            <#+ WriteNotNull("inner"); #>
            Require.NotNull(resultSelector, nameof(resultSelector));
            Require.NotNull(outerKeySelector, nameof(outerKeySelector));
            Require.NotNull(innerKeySelector, nameof(innerKeySelector));
            Require.NotNull(comparer, nameof(comparer));

            var keyLookup = GetKeyLookup(inner, outerKeySelector, innerKeySelector, comparer);

            return outer.Select(val => resultSelector(val, keyLookup(val).Then(inner)));
        }

        private static Func<TSource, <#= Name #><TKey>> GetKeyLookup<TSource, TInner, TKey>(
            <#= Name #><TInner> inner,
            Func<TSource, TKey> outerKeySelector,
            Func<TInner, TKey> innerKeySelector,
            IEqualityComparer<TKey> comparer)
            <#+ WriteTypeConstraints("TSource", "TInner", "TKey"); #>
        {
<#+ if (IsNullable) { #>
            Demand.NotNull("inner");
<#+ } #>
            Demand.NotNull(outerKeySelector);
            Demand.NotNull(innerKeySelector);
            Demand.NotNull(comparer);

            return arg => inner.<#= MapName #>(innerKeySelector)
                .<#= FilterName #>(key => comparer.Equals(key, outerKeySelector(arg)));
        }
<#+ } // T4: End of HasJoin. #>

        #endregion
    } // End of <#= Name #> - T4: EmitMonadExtensions().
<#+
    } // T4: End of EmitMonadExtensions().
} // T4: End of MonadTemplate.

#>