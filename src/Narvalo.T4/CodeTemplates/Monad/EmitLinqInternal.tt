<#+

public partial class MonadTemplate
{
    protected void EmitLinqInternal()
    {
#>
    // Provides default implementations for the extension methods for IEnumerable<T>.
    // You will certainly want to override them to improve performance.
    // T4: EmitLinqInternal().
    internal static partial class EnumerableExtensions
    {
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
        internal static <#= Name #><IEnumerable<TResult><#= RTDecl #>> SelectWithImpl<TSource, TResult<#= RTDecl #>>(
            this IEnumerable<TSource> @this,
            Func<TSource, <#= Name #><TResult<#= RTDecl #>>> selector)
        {
            Debug.Assert(@this != null);
            Debug.Assert(selector != null);

            return @this.Select(selector).Collect();
        }

        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
        internal static <#= Name #><IEnumerable<TSource><#= RTDecl #>> WhereByImpl<TSource<#= RTDecl #>>(
            this IEnumerable<TSource> @this,
            Func<TSource, <#= Name #><bool<#= RTDecl #>>> predicate)
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(predicate, nameof(predicate));

            return <#+ WriteFactory("IEnumerable<TSource>"); #>(WhereByIterator(@this, predicate));
        }

        private static IEnumerable<TSource> WhereByIterator<TSource<#= RTDecl #>>(
            IEnumerable<TSource> source,
            Func<TSource, <#= Name #><bool<#= RTDecl #>>> predicate)
        {
            Debug.Assert(source != null);
            Debug.Assert(predicate != null);
<#+ if (HasRightGenerics) { #>

            var unit = <#+ WriteFactory("Unit"); #>(Unit.Default);
<#+ } #>

            using (var iter = source.GetEnumerator())
            {
                while (iter.MoveNext())
                {
                    bool pass = false;
                    TSource item = iter.Current;

                    predicate(item).Bind(val =>
                    {
                        pass = val;

<#+ if (HasRightGenerics) { #>
                        return unit;
<#+ } else { #>
                        return <#= Name #>.Unit;
<#+ } #>
                    });

                    if (pass) { yield return item; }
                }
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
        internal static <#= Name #><IEnumerable<TResult><#= RTDecl #>> ZipWithImpl<TFirst, TSecond, TResult<#= RTDecl #>>(
            this IEnumerable<TFirst> @this,
            IEnumerable<TSecond> second,
            Func<TFirst, TSecond, <#= Name #><TResult<#= RTDecl #>>> resultSelector)
        {
            Debug.Assert(resultSelector != null);
            Debug.Assert(@this != null);
            Debug.Assert(second != null);

            return @this.Zip(second, resultSelector).Collect();
        }

        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
        internal static <#= Name #><TAccumulate<#= RTDecl #>> FoldImpl<TSource, TAccumulate<#= RTDecl #>>(
            this IEnumerable<TSource> @this,
            TAccumulate seed,
            Func<TAccumulate, TSource, <#= Name #><TAccumulate<#= RTDecl #>>> accumulator)
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulator, nameof(accumulator));

            <#= Name #><TAccumulate<#= RTDecl #>> retval = <#+ WriteFactory("TAccumulate"); #>(seed);

            using (var iter = @this.GetEnumerator())
            {
                while (iter.MoveNext())
                {
<#+ if (IsNullable) { #>
                    if (retval == null) { continue; }

<#+ } #>
                    retval = retval.Bind(val => accumulator(val, iter.Current));
                }
            }

            return retval;
        }

        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
        internal static <#= Name #><TAccumulate<#= RTDecl #>> FoldImpl<TSource, TAccumulate<#= RTDecl #>>(
            this IEnumerable<TSource> @this,
            TAccumulate seed,
            Func<TAccumulate, TSource, <#= Name #><TAccumulate<#= RTDecl #>>> accumulator,
            Func<<#= Name #><TAccumulate<#= RTDecl #>>, bool> predicate)
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulator, nameof(accumulator));
            Require.NotNull(predicate, nameof(predicate));

            <#= Name #><TAccumulate<#= RTDecl #>> retval = <#+ WriteFactory("TAccumulate"); #>(seed);

            using (var iter = @this.GetEnumerator())
            {
                while (predicate(retval) && iter.MoveNext())
                {
<#+ if (IsNullable) { #>
                    if (retval == null) { continue; }

<#+ } #>
                    retval = retval.Bind(val => accumulator(val, iter.Current));
                }
            }

            return retval;
        }

        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
        internal static <#= Name #><TSource<#= RTDecl #>> ReduceImpl<TSource<#= RTDecl #>>(
            this IEnumerable<TSource> @this,
            Func<TSource, TSource, <#= Name #><TSource<#= RTDecl #>>> accumulator)
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulator, nameof(accumulator));

            using (var iter = @this.GetEnumerator())
            {
                if (!iter.MoveNext())
                {
                    throw new InvalidOperationException("Source sequence was empty.");
                }

                <#= Name #><TSource<#= RTDecl #>> retval = <#+ WriteFactory("TSource"); #>(iter.Current);

                while (iter.MoveNext())
                {
<#+ if (IsNullable) { #>
                    if (retval == null) { continue; }

<#+ } #>
                    retval = retval.Bind(val => accumulator(val, iter.Current));
                }

                return retval;
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
        internal static <#= Name #><TSource<#= RTDecl #>> ReduceImpl<TSource<#= RTDecl #>>(
            this IEnumerable<TSource> @this,
            Func<TSource, TSource, <#= Name #><TSource<#= RTDecl #>>> accumulator,
            Func<<#= Name #><TSource<#= RTDecl #>>, bool> predicate)
        {
            <#+ WriteNotNull(true); #>
            Require.NotNull(accumulator, nameof(accumulator));
            Require.NotNull(predicate, nameof(predicate));

            using (var iter = @this.GetEnumerator())
            {
                if (!iter.MoveNext())
                {
                    throw new InvalidOperationException("Source sequence was empty.");
                }

                <#= Name #><TSource<#= RTDecl #>> retval = <#+ WriteFactory("TSource"); #>(iter.Current);

                while (predicate(retval) && iter.MoveNext())
                {
<#+ if (IsNullable) { #>
                    if (retval == null) { continue; }

<#+ } #>
                    retval = retval.Bind(val => accumulator(val, iter.Current));
                }

                return retval;
            }
        }
    }
<#+
    } // T4: End of EmitLinqInternal().
} // T4: End of MonadTemplate.

#>