<#+

public partial class MonadTemplate
{
    protected void EmitMonadCore()
    {
#>
    /// <summary>
    /// Provides a set of static methods for <#= Name #><T>.
    /// </summary>
    // NB: Sometimes we prefer extension methods over static methods to be able to override them locally.
    public static partial class <#= Name #>
    {
        /// <summary>
        /// The unique object of type <c><#= Name #>&lt;Unit&gt;</c>.
        /// </summary>
        private static readonly <#= Name #><global::Narvalo.Fx.Unit> s_Unit = <#= ReturnName #>(global::Narvalo.Fx.Unit.Single);

        /// <summary>
        /// Gets the unique object of type <c><#= Name #>&lt;Unit&gt;</c>.
        /// </summary>
        /// <value>The unique object of type <c><#= Name #>&lt;Unit&gt;</c>.</value>
        public static <#= Name #><global::Narvalo.Fx.Unit> Unit
        {
            get
            {
<#+ if (IsNullable) { #>
                Warrant.NotNull<<#= Name #><global::Narvalo.Fx.Unit>>();
<#+ } #>

                return s_Unit;
            }
        }

<#+ if (HasZero) { #>

        /// <summary>
        /// Gets the zero for <see cref="<#= Name #>{T}"/>.
        /// </summary>
        /// <value>The zero for <see cref="<#= Name #>{T}"/>.</value>
        // Named "mzero" in Haskell parlance.
        public static <#= Name #><global::Narvalo.Fx.Unit> <#= ZeroName #>
        {
            get
            {
<#+ if (IsNullable) { #>
                Warrant.NotNull<<#= Name #><global::Narvalo.Fx.Unit>>();
<#+ } #>

                return <#= Name #><global::Narvalo.Fx.Unit>.<#= ZeroName #>;
            }
        }

<#+ } #>

        /// <summary>
        /// Obtains an instance of the <see cref="<#= Name #>{T}"/> class for the specified value.
        /// </summary>
        /// <typeparam name="T">The underlying type of <paramref name="value"/>.</typeparam>
        /// <param name="value">A value to be wrapped into a <see cref="<#= Name #>{T}"/> object.</param>
        /// <returns>An instance of the <see cref="<#= Name #>{T}"/> class for the specified value.</returns>
        // Named "return" in Haskell parlance.
        public static <#= Name #><T> <#= ReturnName #><T>(T value)
            <#+ WriteTypeConstraints("T"); #>
        {
<#+ if (IsNullable) { #>
            Warrant.NotNull<<#= Name #><T>>();
<#+ } #>

            return <#= Name #><T>.η(value);
        }

        #region Generalisations of list functions (Prelude)

        /// <summary>
        /// Removes one level of structure, projecting its bound value into the outer level.
        /// </summary>
        // Named "join" in Haskell parlance.
        public static <#= Name #><T> Flatten<T>(<#= Name #><<#= Name #><T>> square)
            <#+ WriteTypeConstraints("T"); #>
        {
<#+ if (IsNullable) { #>
            Expect.NotNull(square);
<#+ } #>
<#+ if (PostMultiplicationEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><T>>();
<#+ } #>

            return <#= Name #><T>.μ(square);
        }

        #endregion

        #region Conditional execution of monadic expressions (Prelude)

<#+ if (HasZero) { #>

        // Named "guard" in Haskell parlance.
        public static <#= Name #><global::Narvalo.Fx.Unit> Guard(bool predicate)
        {
<#+ if (IsNullable) { #>
            Warrant.NotNull<<#= Name #><global::Narvalo.Fx.Unit>>();
<#+ } #>

            return predicate ? <#= Name #>.Unit : <#= Name #><global::Narvalo.Fx.Unit>.<#= ZeroName #>;
        }

<#+ } // T4: End of HasZero. #>

        #endregion

        #region Monadic lifting operators (Prelude)

        /// <summary>
        /// Promotes a function to use and return <see cref="<#= Name #>{T}" /> values.
        /// </summary>
        // Named "liftM" in Haskell parlance.
        public static Func<<#= Name #><T>, <#= Name #><TResult>> Lift<T, TResult>(
            Func<T, TResult> thunk)
            <#+ WriteTypeConstraints("T", "TResult"); #>
        {
            Warrant.NotNull<Func<<#= Name #><T>, <#= Name #><TResult>>>();

            return m =>
            {
                <#+ WriteNotNull("m"); #>
                return m.<#= MapName #>(thunk);
            };
        }

        /// <summary>
        /// Promotes a function to use and return <see cref="<#= Name #>{T}" /> values, scanning the
        /// monadic arguments from left to right.
        /// </summary>
        // Named "liftM2" in Haskell parlance.
        public static Func<<#= Name #><T1>, <#= Name #><T2>, <#= Name #><TResult>>
            Lift<T1, T2, TResult>(Func<T1, T2, TResult> thunk)
            <#+ WriteTypeConstraints("T1", "T2", "TResult"); #>
        {
            Warrant.NotNull<Func<<#= Name #><T1>, <#= Name #><T2>, <#= Name #><TResult>>>();

            return (m1, m2) =>
            {
                <#+ WriteNotNull("m1"); #>
                return m1.Zip(m2, thunk);
            };
        }

        /// <summary>
        /// Promotes a function to use and return <see cref="<#= Name #>{T}" /> values, scanning the
        /// monadic arguments from left to right.
        /// </summary>
        // Named "liftM3" in Haskell parlance.
        public static Func<<#= Name #><T1>, <#= Name #><T2>, <#= Name #><T3>, <#= Name #><TResult>>
            Lift<T1, T2, T3, TResult>(Func<T1, T2, T3, TResult> thunk)
            <#+ WriteTypeConstraints("T1", "T2", "T3", "TResult"); #>
        {
            Warrant.NotNull<Func<<#= Name #><T1>, <#= Name #><T2>, <#= Name #><T3>, <#= Name #><TResult>>>();

            return (m1, m2, m3) =>
            {
                <#+ WriteNotNull("m1"); #>
                return m1.Zip(m2, m3, thunk);
            };
        }

        /// <summary>
        /// Promotes a function to use and return <see cref="<#= Name #>{T}" /> values, scanning the
        /// monadic arguments from left to right.
        /// </summary>
        // Named "liftM4" in Haskell parlance.
        public static Func<<#= Name #><T1>, <#= Name #><T2>, <#= Name #><T3>, <#= Name #><T4>, <#= Name #><TResult>>
            Lift<T1, T2, T3, T4, TResult>(
            Func<T1, T2, T3, T4, TResult> thunk)
            <#+ WriteTypeConstraints("T1", "T2", "T3", "T4", "TResult"); #>
        {
            Warrant.NotNull<Func<<#= Name #><T1>, <#= Name #><T2>, <#= Name #><T3>, <#= Name #><T4>, <#= Name #><TResult>>>();

            return (m1, m2, m3, m4) =>
            {
                <#+ WriteNotNull("m1"); #>
                return m1.Zip(m2, m3, m4, thunk);
            };
        }

        /// <summary>
        /// Promotes a function to use and return <see cref="<#= Name #>{T}" /> values, scanning the
        /// monadic arguments from left to right.
        /// </summary>
        // Named "liftM5" in Haskell parlance.
        public static Func<<#= Name #><T1>, <#= Name #><T2>, <#= Name #><T3>, <#= Name #><T4>, <#= Name #><T5>, <#= Name #><TResult>>
            Lift<T1, T2, T3, T4, T5, TResult>(
            Func<T1, T2, T3, T4, T5, TResult> thunk)
            <#+ WriteTypeConstraints("T1", "T2", "T3", "T4", "T5", "TResult"); #>
        {
            Warrant.NotNull<Func<<#= Name #><T1>, <#= Name #><T2>, <#= Name #><T3>, <#= Name #><T4>, <#= Name #><T5>, <#= Name #><TResult>>>();

            return (m1, m2, m3, m4, m5) =>
            {
                <#+ WriteNotNull("m1"); #>
                return m1.Zip(m2, m3, m4, m5, thunk);
            };
        }

        #endregion
    } // End of <#= Name #> - T4: EmitMonadCore().
<#+
    } // T4: End of EmitMonadCore().
} // T4: End of MonadTemplate.

#>