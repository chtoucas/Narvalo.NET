<#+

public partial class MonadTemplate
{
    protected void EmitMonadEnumerableInternalExtensions()
    {
#>
    /// <content>
    /// Provides the core extension methods for <see cref="IEnumerable{T}"/> where <c>T</c> is a <see cref="Maybe{S}"/>.
    /// </content>
    internal static partial class EnumerableExtensions
    {

<#+ if (!HasTypeConstraints) { #>

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><IEnumerable<TSource>> CollectCore<TSource>(
            this IEnumerable<<#= Name #><TSource>> @this)
        {
            Demand.NotNull(@this);
<#+ if (IsNullable) { #>
            Warrant.NotNull<<#= Name #><IEnumerable<TSource>>>();
<#+ } #>

            var seed = <#= Name #>.<#= ReturnName #>(Enumerable.Empty<TSource>());
            Func<<#= Name #><IEnumerable<TSource>>, <#= Name #><TSource>, <#= Name #><IEnumerable<TSource>>> fun
                = (m, n) => m.Bind(list => CollectCore(n, list));

            var retval = @this.Aggregate(seed, fun);
<#+ if (IsNullable) { #>
            System.Diagnostics.Contracts.Contract.Assume(retval != null);
<#+ } #>

            return retval;
        }

        // NB: We do not inline this method to avoid the creation of an unused private field (CA1823 warning).
        private static <#= Name #><IEnumerable<TSource>> CollectCore<TSource>(
            <#= Name #><TSource> m,
            IEnumerable<TSource> list)
        {
<#+ if (IsNullable) { #>
            Demand.NotNull(m);
<#+ } #>

            return m.Bind(item => <#= Name #>.<#= ReturnName #>(list.Concat(Enumerable.Repeat(item, 1))));
        }

<#+ } // T4: End of !HasTypeConstraints. #>

<#+ if (HasSum) { #>

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TSource> SumCore<TSource>(
            this IEnumerable<<#= Name #><TSource>> @this)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            Demand.NotNull(@this);
<#+ if (IsNullable) { #>
            Warrant.NotNull<<#= Name #><TSource>>();
<#+ } #>

            var retval = @this.Aggregate(<#= Name #><TSource>.<#= ZeroName #>, (m, n) => m.<#= PlusName #>(n));
<#+ if (IsNullable) { #>
            System.Diagnostics.Contracts.Contract.Assume(retval != null);
<#+ } #>

            return retval;
        }

<#+ } // T4: End of HasSum. #>
    } // End of EnumerableExtensions - T4: EmitMonadEnumerableInternalExtensions().
<#+
    } // T4: End of EmitMonadEnumerableInternalExtensions().
} // T4: End of MonadTemplate.

#>