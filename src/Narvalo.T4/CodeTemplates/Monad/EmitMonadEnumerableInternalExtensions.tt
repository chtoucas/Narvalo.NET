<#+

public partial class MonadTemplate
{
    protected void EmitMonadEnumerableInternalExtensions()
    {
#>
    // Provides the core extension methods for IEnumerable<T> where T is a <#= Name #><S>.
    internal static partial class EnumerableExtensions
    {

<#+ if (!HasTypeConstraints) { #>

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><IEnumerable<TSource>> CollectImpl<TSource>(
            this IEnumerable<<#= Name #><TSource>> @this)
        {
            Demand.NotNull(@this);
<#+ if (IsNullable) { #>
            Warrant.NotNull<<#= Name #><IEnumerable<TSource>>>();
<#+ } #>

            var seed = <#= Name #>.<#= ReturnName #>(Enumerable.Empty<TSource>());
            // Inlined LINQ Append method:
            Func<IEnumerable<TSource>, TSource, IEnumerable<TSource>> append = (m, item) => m.Append(item);

            // NB: Maybe.Lift(append) is the same as:
            // Func<<#= Name #><IEnumerable<TSource>>, <#= Name #><TSource>, <#= Name #><IEnumerable<TSource>>> liftedAppend
            //     = (m, item) => m.Bind(list => Append(list, item));
            // where Append is defined below.
            var retval = @this.Aggregate(seed, <#= Name #>.Lift(append));
<#+ if (IsNullable) { #>
            System.Diagnostics.Contracts.Contract.Assume(retval != null);
<#+ } #>

            return retval;
        }

        // NB: We do not inline this method to avoid the creation of an unused private field (CA1823 warning).
        //private static <#= Name #><IEnumerable<TSource>> Append<TSource>(
        //    IEnumerable<TSource> list,
        //    <#= Name #><TSource> m)
        //{
<#+ if (IsNullable) { #>
        //    Demand.NotNull(m);
<#+ } #>

        //    return m.Bind(item => <#= Name #>.<#= ReturnName #>(list.Concat(Enumerable.Repeat(item, 1))));
        //}

<#+ } // T4: End of !HasTypeConstraints. #>

<#+ if (HasSum) { #>

<#+ if (!SuppressMessage) { #>
        [SuppressMessage("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode", Justification = "[GeneratedCode] This method has been overridden locally.")]
<#+ } #>
        internal static <#= Name #><TSource> SumImpl<TSource>(
            this IEnumerable<<#= Name #><TSource>> @this)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            Demand.NotNull(@this);
<#+ if (IsNullable) { #>
            Warrant.NotNull<<#= Name #><TSource>>();
<#+ } #>

            var retval = @this.Aggregate(<#= Name #><TSource>.<#= ZeroName #>, (m, n) => m.<#= PlusName #>(n));
<#+ if (IsNullable) { #>
            System.Diagnostics.Contracts.Contract.Assume(retval != null);
<#+ } #>

            return retval;
        }

<#+ } // T4: End of HasSum. #>
    } // End of EnumerableExtensions - T4: EmitMonadEnumerableInternalExtensions().
<#+
    } // T4: End of EmitMonadEnumerableInternalExtensions().
} // T4: End of MonadTemplate.

#>