<#+

public partial class MonadTemplate
{
    public void EmitKleisliExtensions(bool haslinq)
    {
#>
    // Provides extension methods for Func<T> in the Kleisli category + one Applicative.
    public static partial class Func
    {
        #region Applicative

<#+ if (!HasTypeConstraints) { #>

        // Named "<**>" in Haskell parlance. Same as Gather (<*>) with its arguments flipped.
        public static <#= Name #><TResult<#= SuffixT #>> Apply<TSource, TResult<#= SuffixT #>>(
            this <#= Name #><Func<TSource, TResult><#= SuffixT #>> @this,
            <#= Name #><TSource<#= SuffixT #>> value)
        {
            <#+ WriteNotNull(); #>
            <#+ WriteNotNull("value"); #>

            return @this.Bind(thunk => value.Select(v => thunk.Invoke(v)));
        }

<#+ } // T4: End of !HasTypeConstraints. #>

        #endregion

        #region Basic Monad functions (Prelude)

<#+ if (!HasTypeConstraints) { #>

        // Named "forM" in Haskell parlance. Same as Map (mapM) with its arguments flipped.
        public static <#= Name #><IEnumerable<TResult><#= SuffixT #>> ForEach<TSource, TResult<#= SuffixT #>>(
            this Func<TSource, <#= Name #><TResult<#= SuffixT #>>> @this,
            IEnumerable<TSource> seq)
        {
            Expect.NotNull(@this);
            Expect.NotNull(seq);
<#+ if (IsNullable) { #>
            Warrant.NotNull<<#= Name #><IEnumerable<TResult><#= SuffixT #>>>();
<#+ } #>
<#+ WriteLine(); #>

<#+ if (haslinq) { #>
            return seq.SelectWith(@this);
<#+ } else { #>
            return seq.Select(@this).EmptyIfNull().Collect();
<#+ } #>
        }

<#+ } // T4: End of !HasTypeConstraints. #>

        // Named "=<<" in Haskell parlance. Same as Bind (>>=) with its arguments flipped.
        public static <#= Name #><TResult<#= SuffixT #>> Invoke<TSource, TResult<#= SuffixT #>>(
            this Func<TSource, <#= Name #><TResult<#= SuffixT #>>> @this,
            <#= Name #><TSource<#= SuffixT #>> value)
            <#+ WriteTypeConstraints("TSource", "TResult"); #>
        {
            Expect.NotNull(@this);
            <#+ WriteNotNull("value"); #>
<#+ if (PostBindEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult<#= SuffixT #>>>();
<#+ } #>

            return value.Bind(@this);
        }

        // Named ">=>" in Haskell parlance.
        public static Func<TSource, <#= Name #><TResult<#= SuffixT #>>> Compose<TSource, TMiddle, TResult<#= SuffixT #>>(
            this Func<TSource, <#= Name #><TMiddle<#= SuffixT #>>> @this,
            Func<TMiddle, <#= Name #><TResult<#= SuffixT #>>> thunk)
            <#+ WriteTypeConstraints("TSource", "TMiddle", "TResult"); #>
        {
            <#+ WriteNotNull(true); #>
            Expect.NotNull(thunk);
            Warrant.NotNull<Func<TSource, <#= Name #><TResult<#= SuffixT #>>>>();

            return _ => @this.Invoke(_).Bind(thunk);
        }

        // Named "<=<" in Haskell parlance.
        public static Func<TSource, <#= Name #><TResult<#= SuffixT #>>> ComposeBack<TSource, TMiddle, TResult<#= SuffixT #>>(
            this Func<TMiddle, <#= Name #><TResult<#= SuffixT #>>> @this,
            Func<TSource, <#= Name #><TMiddle<#= SuffixT #>>> thunk)
            <#+ WriteTypeConstraints("TSource", "TMiddle", "TResult"); #>
        {
            Expect.NotNull(@this);
            Require.NotNull(thunk, nameof(thunk));
            Warrant.NotNull<Func<TSource, <#= Name #><TResult<#= SuffixT #>>>>();

            return _ => thunk.Invoke(_).Bind(@this);
        }

        #endregion
    } // End of Func - T4: EmitKleisliExtensions().
<#+
    } // T4: End of EmitKleisliExtensions().
} // T4: End of MonadTemplate.

#>