<#+

public partial class MonadTemplate
{
    protected void EmitMonadExtraExtensions()
    {
#>
    // Provides more extension methods for <#= Name #><T<#= SuffixT #>>.
    public static partial class <#= Name #>Extensions
    {
        #region Basic Monad functions

        // Named "forever" in Haskell parlance.
        public static <#= Name #><TResult<#= SuffixT #>> Forever<TSource, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<<#= Name #><TResult<#= SuffixT #>>> thunk)
            <#+ WriteTypeConstraints("TSource", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
<#+ if (PostThenEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult<#= SuffixT #>>>();
<#+ } #>

            return @this.ContinueWith(@this.Forever(thunk));
        }

        #endregion

        #region Conditional execution of monadic expressions

        // Named "when" in Haskell parlance. Haskell uses a different signature.
        public static void When<TSource<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, bool> predicate,
            Action<TSource> action)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(); #>
            Require.NotNull(predicate, nameof(predicate));
            Require.NotNull(action, nameof(action));

            @this.Bind(
                _ => {
                    if (predicate.Invoke(_)) { action.Invoke(_); }

<#+ if (HasSuffixT) { #>
                    return @this.Skip();
<#+ } else { #>
                    return <#= Name #>.Unit;
<#+ } #>
                });
        }

        // Named "unless" in Haskell parlance. Haskell uses a different signature.
        public static void Unless<TSource<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, bool> predicate,
            Action<TSource> action)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(); #>
            Require.NotNull(predicate, nameof(predicate));
            Require.NotNull(action, nameof(action));

            @this.Bind(
                _ => {
                    if (!predicate.Invoke(_)) { action.Invoke(_); }

<#+ if (HasSuffixT) { #>
                    return @this.Skip();
<#+ } else { #>
                    return <#= Name #>.Unit;
<#+ } #>
                });
        }

        #endregion

        #region Applicative

<#+ if (!HasTypeConstraints) { #>

        // Named "<*>" in Haskell parlance. Same as Apply (<**>) with its arguments flipped.
        public static <#= Name #><TResult<#= SuffixT #>> Gather<TSource, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            <#= Name #><Func<TSource, TResult><#= SuffixT #>> applicative)
            <#+ WriteTypeConstraints("TSource", "TResult"); #>
        {
            <#+ WriteNotNull("applicative"); #>

            return applicative.Apply(@this);
        }

<#+ } // T4: End of !HasTypeConstraints. #>

        #endregion

        public static <#= Name #><TResult<#= SuffixT #>> Coalesce<TSource, TResult<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Func<TSource, bool> predicate,
            <#= Name #><TResult<#= SuffixT #>> then,
            <#= Name #><TResult<#= SuffixT #>> otherwise)
            <#+ WriteTypeConstraints("TSource", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            Require.NotNull(predicate, nameof(predicate));
<#+ if (PostBindEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult<#= SuffixT #>>>();
<#+ } #>

            return @this.Bind(_ => predicate.Invoke(_) ? then : otherwise);
        }

<#+ if (HasZero) { #>

        public static <#= Name #><TResult> If<TSource, TResult>(
            this <#= Name #><TSource> @this,
            Func<TSource, bool> predicate,
            <#= Name #><TResult> other)
            <#+ WriteTypeConstraints("TSource", "TResult"); #>
        {
            <#+ WriteNotNull(); #>
            Require.NotNull(predicate, nameof(predicate));
<#+ if (PostBindEnsuresSome) { #>
            Warrant.NotNull<<#= Name #><TResult>>();
<#+ } #>

            return @this.Bind(_ => predicate.Invoke(_) ? other : <#= Name #><TResult>.<#= ZeroName #>);
        }

<#+ } // T4: End of HasZero. #>
        public static void Do<TSource<#= SuffixT #>>(
            this <#= Name #><TSource<#= SuffixT #>> @this,
            Action<TSource> action)
            <#+ WriteTypeConstraints("TSource"); #>
        {
            <#+ WriteNotNull(); #>
            Require.NotNull(action, nameof(action));

            @this.Bind(
                _ => {
                    action.Invoke(_);

<#+ if (HasSuffixT) { #>
                    return @this.Skip();
<#+ } else { #>
                    return <#= Name #>.Unit;
<#+ } #>
                });
        }
    } // End of <#= Name #> - T4: EmitMonadExtraExtensions().
<#+
    } // T4: End of EmitMonadExtraExtensions().
} // T4: End of MonadTemplate.

#>