<#@ assembly name="$(T4NarvaloLibrary)" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ import namespace="Narvalo.T4" #>
<#@ include file="Monad\EmitMonadCore.tt" #>
<#@ include file="Monad\EmitMonadExtensions.tt" #>
<#@ include file="Monad\EmitKleisliExtensions.tt" #>
<#@ include file="Monad\EmitMonadEnumerableExtensions.tt" #>
<#@ include file="Monad\EmitMonadEnumerableInternalExtensions.tt" #>
<#@ include file="Monad\EmitEnumerableExtensions.tt" #>
<#@ include file="Monad\EmitEnumerableInternalExtensions.tt" #>
<#@ include file="Monad\EmitComonadCore.tt" #><#+

// WARNING: This is only a proof of concept.
// This file depends on Narvalo.Cerbere & Narvalo.Fx packages for four things:
// - the classes Acknowledge, Assume and Require in the Narvalo namespace.
// - the Unit class in the Narvalo.Fx namespace; but you can define your own: see UnitFullName.
// The generated files are free of CA warnings except for CA1006:DoNotNestGenericTypesInMemberSignatures.

// TODO: Protect the various T4 property's setters.
// Better separation of concerns.

// The following is going to change:
// Some documentation is almost blindly copied from Haskell.
// If the monad does have a zero, we do expect "Bind" & "η" to never return null but the zero.
// If the monad does not have a zero, we do not have any expectation on the return value of Bind.

public abstract partial class MonadTemplate : _MonadTemplate
{
    protected MonadTemplate(TextTransformation parent) : base(parent) { }

    // EmitMonad -----------------------------------------------------------------------------------

    // Generates a Monad.
    public void EmitMonad()
    {
#>
namespace <#= Namespace #>
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.Contracts;
    using System.Linq;

    using global::Narvalo;

<#+ EmitMonadCore(); #>

<#+ EmitMonadExtensions(); #>

<#+ EmitKleisliExtensions(); #>
}
<#+
    } // T4: End of EmitMonad().

    // EmitComonad ---------------------------------------------------------------------------------

    // Generates a Comonad.
    public void EmitComonad()
    {
#>
namespace <#= Namespace #>
{
    using System.Diagnostics.Contracts;

<#+ EmitComonadCore(); #>
}
<#+
    } // T4: End of EmitComonad().

    // EmitLinq ------------------------------------------------------------------------------------

    // Generates the LINQ extensions.
    public void EmitLinq()
    {
#>
namespace <#= Namespace #>
{
    using System.Collections.Generic;
    using System.Diagnostics.Contracts;

    using <#= Namespace #>.Internal;

<#+ EmitMonadEnumerableExtensions(); #>
}

namespace <#= AdvancedNamespace #>
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.Contracts;

    using <#= Namespace #>;
    using <#= Namespace #>.Internal;

<#+ EmitEnumerableExtensions(); #>
}

namespace <#= Namespace #>.Internal
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.Contracts;
    using System.Linq;

    using global::Narvalo;
    using Narvalo.Fx; // Necessary for EmptyIfNull().
<#+ if (Namespace != "Narvalo.Fx") { #>
    using <#= Namespace #>;
<#+ } #>
<#+ if (Namespace != AdvancedNamespace) { #>
    using <#= AdvancedNamespace #>;
<#+ } #>

<#+ EmitMonadEnumerableInternalExtensions(); #>

<#+ EmitEnumerableInternalExtensions(); #>
}
<#+
    } // T4: End of EmitLinq().

    protected override void WriteHeader()
    {
        base.WriteHeader();

        // See http://msdn.microsoft.com/en-us/library/ms244717.aspx for an explanation
        // of the effect of the SuppressMessage attribute at module scope.
        // This suppresses the corresponding warnings for the code inside the generated file.
        // We either favour T4 readibility over StyleCop rules or disable rules that do not make sense
        // for files generated by a Text Template.
#>

using global::System.Diagnostics.CodeAnalysis;

[module: SuppressMessage("StyleCop.CSharp.OrderingRules", "SA1202:ElementsMustBeOrderedByAccess",
    Justification = "[GeneratedCode] Elements are correctly ordered in the T4 source file.")]
[module: SuppressMessage("StyleCop.CSharp.OrderingRules", "SA1210:UsingDirectivesMustBeOrderedAlphabeticallyByNamespace",
    Justification = "[GeneratedCode] Directives are correctly ordered in the T4 source file.")]
[module: SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:FileMayOnlyContainASingleClass",
    Justification = "[GeneratedCode] A T4 template may contain multiple classes.")]
[module: SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1403:FileMayOnlyContainASingleNamespace",
    Justification = "[GeneratedCode] A T4 template may contain multiple namespaces.")]
[module: SuppressMessage("StyleCop.CSharp.LayoutRules", "SA1505:OpeningCurlyBracketsMustNotBeFollowedByBlankLine",
    Justification = "[GeneratedCode] Newline rules are disabled for T4 templates.")]
[module: SuppressMessage("StyleCop.CSharp.LayoutRules", "SA1507:CodeMustNotContainMultipleBlankLinesInARow",
    Justification = "[GeneratedCode] Newline rules are disabled for T4 templates.")]

<#+
    } // T4: End of WriteHeader().

    /* ========================================================================================== *
     * Private Methods
     * ========================================================================================== */

    private void WriteTypeConstraints_(params string[] names)
    {
        if (HasUnderlyingTypeConstraint) {
            foreach (var name in names) {
#>
            where <#= name #> : <#= UnderlyingTypeConstraint #>
<#+
            }
        }
    } // T4: End of WriteTypeConstraints_().

    private void WriteObjectNotNull_(bool force = false)
    {
        if (force || IsNullable) {
#>
            Require.Object(@this);
<#+
        }
    } // T4: End of WriteObjectNotNull_().

    private void WriteNotNull_(string name)
    {
        if (IsNullable) {
#>
            Require.NotNull(<#= name #>, "<#= name #>");
<#+
        }
    } // T4: End of WriteNotNull_().

}

#>
