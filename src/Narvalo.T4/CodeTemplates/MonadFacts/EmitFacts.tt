<#+

public partial class MonadTemplate
{
    public void EmitFacts()
    {
#>
namespace <#= Namespace #>
{
    using System;
    using System.Collections.Generic;

    using FsCheck.Xunit;
    using Xunit;

    public static partial class <#= Name #>Facts
    {
        #region Repeat()

        [Fact]
        public static void Repeat_ThrowsArgumentOutOfRangeException_ForNegativeCount()
        {
            var source = <#= Name #>.<#= ReturnName #>(1);

            Assert.Throws<ArgumentOutOfRangeException>(() => <#= Name #>.Repeat(source, -1));
        }

        #endregion

        #region Zip()

        [Fact]
        public static void Zip2_ThrowsArgumentNullException_ForNullZipper()
        {
            var first = <#= Name #>.<#= ReturnName #>(1);
            var second = <#= Name #>.<#= ReturnName #>(2);
            Func<int, int, int> zipper = null;

            Assert.Throws<ArgumentNullException>(() => first.Zip(second, zipper));
            Assert.Throws<ArgumentNullException>(() => <#= ExtensionsClsName #>.Zip(first, second, zipper));
        }

        [Fact]
        public static void Zip3_ThrowsArgumentNullException_ForNullZipper()
        {
            var first = <#= Name #>.<#= ReturnName #>(1);
            var second = <#= Name #>.<#= ReturnName #>(2);
            var third = <#= Name #>.<#= ReturnName #>(3);
            Func<int, int, int, int> zipper = null;

            Assert.Throws<ArgumentNullException>(() => first.Zip(second, third, zipper));
            Assert.Throws<ArgumentNullException>(() => <#= ExtensionsClsName #>.Zip(first, second, third, zipper));
        }

        [Fact]
        public static void Zip4_ThrowsArgumentNullException_ForNullZipper()
        {
            var first = <#= Name #>.<#= ReturnName #>(1);
            var second = <#= Name #>.<#= ReturnName #>(2);
            var third = <#= Name #>.<#= ReturnName #>(3);
            var fourth = <#= Name #>.<#= ReturnName #>(4);
            Func<int, int, int, int, int> zipper = null;

            Assert.Throws<ArgumentNullException>(() => first.Zip(second, third, fourth, zipper));
            Assert.Throws<ArgumentNullException>(() => <#= ExtensionsClsName #>.Zip(first, second, third, fourth, zipper));
        }

        [Fact]
        public static void Zip5_ThrowsArgumentNullException_ForNullZipper()
        {
            var first = <#= Name #>.<#= ReturnName #>(1);
            var second = <#= Name #>.<#= ReturnName #>(2);
            var third = <#= Name #>.<#= ReturnName #>(3);
            var fourth = <#= Name #>.<#= ReturnName #>(4);
            var fifth = <#= Name #>.<#= ReturnName #>(4);
            Func<int, int, int, int, int, int> zipper = null;

            Assert.Throws<ArgumentNullException>(() => first.Zip(second, third, fourth, fifth, zipper));
            Assert.Throws<ArgumentNullException>(() => <#= ExtensionsClsName #>.Zip(first, second, third, fourth, fifth, zipper));
        }

        #endregion

        #region <#= MapName #>()

        [Fact]
        public static void Select_ThrowsArgumentNullException_ForNullSelector()
        {
            var source = <#= Name #>.<#= ReturnName #>(1);
            Func<int, int> selector = null;

            Assert.Throws<ArgumentNullException>(() => source.Select(selector));
            Assert.Throws<ArgumentNullException>(() => <#= ExtensionsClsName #>.Select(source, selector));
        }

        #endregion

<#+ if (HasFilter) { #>
        #region Where()

        [Fact]
        public static void Where_ThrowsArgumentNullException_ForNullPredicate()
        {
            var source = <#= Name #>.<#= ReturnName #>(1);
            Func<int, bool> predicate = null;

            Assert.Throws<ArgumentNullException>(() => source.Where(predicate));
            Assert.Throws<ArgumentNullException>(() => <#= ExtensionsClsName #>.Where(source, predicate));
        }

        #endregion

<#+ } // T4: End of HasFilter. #>
        #region SelectMany()

        [Fact]
        public static void SelectMany_ThrowsArgumentNullException_ForNullValueSelector()
        {
            var source = <#= Name #>.<#= ReturnName #>(1);
            Func<int, <#= Name #><int>> valueSelector = null;
            Func<int, int, int> resultSelector = (i, j) => i + j;

            Assert.Throws<ArgumentNullException>(() => source.SelectMany(valueSelector, resultSelector));
            Assert.Throws<ArgumentNullException>(() => <#= ExtensionsClsName #>.SelectMany(source, valueSelector, resultSelector));
        }

        [Fact]
        public static void SelectMany_ThrowsArgumentNullException_ForNullResultSelector()
        {
            var source = <#= Name #>.<#= ReturnName #>(1);
            var middle = <#= Name #>.<#= ReturnName #>(2);
            Func<int, <#= Name #><int>> valueSelector = _ => middle;
            Func<int, int, int> resultSelector = null;

            Assert.Throws<ArgumentNullException>(() => source.SelectMany(valueSelector, resultSelector));
            Assert.Throws<ArgumentNullException>(() => <#= ExtensionsClsName #>.SelectMany(source, valueSelector, resultSelector));
        }

        #endregion

<#+ if (HasJoin) { #>
        #region Join()

        [Fact]
        public static void Join_ThrowsArgumentNullException_ForNullResultSelector()
        {
            var source = <#= Name #>.<#= ReturnName #>(1);
            var inner = <#= Name #>.<#= ReturnName #>(2);
            Func<int, int> outerKeySelector = val => val;
            Func<int, int> innerKeySelector = val => val;
            Func<int, int, int> resultSelector = null;

            Assert.Throws<ArgumentNullException>(
                () => source.Join(inner, outerKeySelector, innerKeySelector, resultSelector));
            Assert.Throws<ArgumentNullException>(
                () => <#= ExtensionsClsName #>.Join(source, inner, outerKeySelector, innerKeySelector, resultSelector));
        }

        [Fact]
        public static void Join_ThrowsArgumentNullException_ForNullOuterKeySelector()
        {
            var source = <#= Name #>.<#= ReturnName #>(1);
            var inner = <#= Name #>.<#= ReturnName #>(2);
            Func<int, int> outerKeySelector = null;
            Func<int, int> innerKeySelector = val => val;
            Func<int, int, int> resultSelector = (i, j) => i + j;

            Assert.Throws<ArgumentNullException>(
                () => source.Join(inner, outerKeySelector, innerKeySelector, resultSelector));
            Assert.Throws<ArgumentNullException>(
                () => <#= ExtensionsClsName #>.Join(source, inner, outerKeySelector, innerKeySelector, resultSelector));
        }

        [Fact]
        public static void Join_ThrowsArgumentNullException_ForNullInnerKeySelector()
        {
            var source = <#= Name #>.<#= ReturnName #>(1);
            var inner = <#= Name #>.<#= ReturnName #>(2);
            Func<int, int> outerKeySelector = val => val;
            Func<int, int> innerKeySelector = null;
            Func<int, int, int> resultSelector = (i, j) => i + j;

            Assert.Throws<ArgumentNullException>(
                () => source.Join(inner, outerKeySelector, innerKeySelector, resultSelector));
            Assert.Throws<ArgumentNullException>(
                () => <#= ExtensionsClsName #>.Join(source, inner, outerKeySelector, innerKeySelector, resultSelector));
        }

        [Fact]
        public static void Join_ThrowsArgumentNullException_ForNullComparer()
        {
            var source = <#= Name #>.<#= ReturnName #>(1);
            var inner = <#= Name #>.<#= ReturnName #>(2);
            Func<int, int> outerKeySelector = val => val;
            Func<int, int> innerKeySelector = val => val;
            Func<int, int, int> resultSelector = (i, j) => i + j;
            IEqualityComparer<int> comparer = null;

            Assert.Throws<ArgumentNullException>(
                () => source.Join(inner, outerKeySelector, innerKeySelector, resultSelector, comparer));
            Assert.Throws<ArgumentNullException>(
                () => <#= ExtensionsClsName #>.Join(source, inner, outerKeySelector, innerKeySelector, resultSelector, comparer));
        }

        #endregion

        #region GroupJoin()

        [Fact]
        public static void GroupJoin_ThrowsArgumentNullException_ForNullResultSelector()
        {
            var source = <#= Name #>.<#= ReturnName #>(1);
            var inner = <#= Name #>.<#= ReturnName #>(2);
            Func<int, int> outerKeySelector = val => val;
            Func<int, int> innerKeySelector = val => val;
            Func<int, <#= Name #><int>, int> resultSelector = null;

            Assert.Throws<ArgumentNullException>(
                () => source.GroupJoin(inner, outerKeySelector, innerKeySelector, resultSelector));
            Assert.Throws<ArgumentNullException>(
                () => <#= ExtensionsClsName #>.GroupJoin(source, inner, outerKeySelector, innerKeySelector, resultSelector));
        }

        [Fact]
        public static void GroupJoin_ThrowsArgumentNullException_ForNullOuterKeySelector()
        {
            var source = <#= Name #>.<#= ReturnName #>(1);
            var inner = <#= Name #>.<#= ReturnName #>(2);
            Func<int, int> outerKeySelector = null;
            Func<int, int> innerKeySelector = val => val;
            Func<int, <#= Name #><int>, int> resultSelector = (i, m) => 1;

            Assert.Throws<ArgumentNullException>(
                () => source.GroupJoin(inner, outerKeySelector, innerKeySelector, resultSelector));
            Assert.Throws<ArgumentNullException>(
                () => <#= ExtensionsClsName #>.GroupJoin(source, inner, outerKeySelector, innerKeySelector, resultSelector));
        }

        [Fact]
        public static void GroupJoin_ThrowsArgumentNullException_ForNullInnerKeySelector()
        {
            var source = <#= Name #>.<#= ReturnName #>(1);
            var inner = <#= Name #>.<#= ReturnName #>(2);
            Func<int, int> outerKeySelector = val => val;
            Func<int, int> innerKeySelector = null;
            Func<int, <#= Name #><int>, int> resultSelector = (i, m) => 1;

            Assert.Throws<ArgumentNullException>(
                () => source.GroupJoin(inner, outerKeySelector, innerKeySelector, resultSelector));
            Assert.Throws<ArgumentNullException>(
                () => <#= ExtensionsClsName #>.GroupJoin(source, inner, outerKeySelector, innerKeySelector, resultSelector));
        }

        [Fact]
        public static void GroupJoin_ThrowsArgumentNullException_ForNullComparer()
        {
            var source = <#= Name #>.<#= ReturnName #>(1);
            var inner = <#= Name #>.<#= ReturnName #>(2);
            Func<int, int> outerKeySelector = val => val;
            Func<int, int> innerKeySelector = val => val;
            Func<int, <#= Name #><int>, int> resultSelector = (i, m) => 1;
            IEqualityComparer<int> comparer = null;

            Assert.Throws<ArgumentNullException>(
                () => source.GroupJoin(inner, outerKeySelector, innerKeySelector, resultSelector, comparer));
            Assert.Throws<ArgumentNullException>(
                () => <#= ExtensionsClsName #>.GroupJoin(source, inner, outerKeySelector, innerKeySelector, resultSelector, comparer));
        }

        #endregion

<#+ } // T4: End of HasJoin. #>
        #region Functor Rules

        [Fact(DisplayName = "<#= Name #><T<#= RTDecl #>> - The identity map is a fixed point for <#= MapName #>.")]
        public static void Satisfies_FirstFunctorLaw()
        {
            // Arrange
            var me = <#= Name #>.<#= ReturnName #>(1);

            // Act
            var left = me.<#= MapName #>(Stubs<int>.Identity);
            var right = Stubs<<#= Name #><int>>.Identity(me);

            // Assert
            Assert.True(left.Equals(right));
        }

        [Fact(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= MapName #> preserves the composition operator.")]
        public static void Satisfies_FunctorSecondRule()
        {
            // Arrange
            var me = <#= Name #>.<#= ReturnName #>(1);
            Func<int, long> g = val => (long)2 * val;
            Func<long, long> f = val => 3 * val;

            // Act
            var left = me.<#= MapName #>(_ => f(g(_)));
            var right = me.<#= MapName #>(g).<#= MapName #>(f);

            // Assert
            Assert.True(left.Equals(right));
        }

        #endregion

<#+ if (HasZero && HasPlus) { #>
        #region Monoid Rules

        [Fact(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= ZeroName #> is a left identity for <#= PlusName #>.")]
        public static void Satisfies_FirstMonoidRule()
        {
            // Arrange
            var monad = <#= Name #>.<#= ReturnName #>(1);

            // Act
            var left = <#= Name #><int>.<#= ZeroName #>.<#= PlusName #>(monad);
            var right = monad;

            // Assert
            Assert.True(left.Equals(right));
        }

        [Fact(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= ZeroName #> is a right identity for <#= PlusName #>.")]
        public static void Satisfies_SecondMonoidRule()
        {
            // Arrange
            var monad = <#= Name #>.<#= ReturnName #>(1);

            // Act
            var left = monad.<#= PlusName #>(<#= Name #><int>.<#= ZeroName #>);
            var right = monad;

            // Assert
            Assert.True(left.Equals(right));
        }

        [Fact(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= PlusName #> is associative.")]
        public static void Satisfies_ThirdMonoidRule()
        {
            // Arrange
            var monadA = <#= Name #>.<#= ReturnName #>(1);
            var monadB = <#= Name #>.<#= ReturnName #>(2);
            var monadC = <#= Name #>.<#= ReturnName #>(3);

            // Act
            var left = monadA.<#= PlusName #>(monadB.<#= PlusName #>(monadC));
            var right = monadA.<#= PlusName #>(monadB).<#= PlusName #>(monadC);

            // Assert
            Assert.True(left.Equals(right));
        }

        #endregion

<#+ } // T4: End of HasZero && HasPlus. #>
        #region Monad Rules

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= ReturnName #> is a left identity for Bind (first monad rule).")]
        public static bool <#= ReturnName #>_IsLeftIdentityForBind(int arg0, float arg1)
        {
            Func<int, <#= Name #><float>> binder = val => <#= Name #>.<#= ReturnName #>(arg1 * val);

            var left = <#= Name #>.<#= ReturnName #>(arg0).Bind(binder);
            var right = binder(arg0);

            return left.Equals(right);
        }

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= ReturnName #> is a left identity for Compose (first monad rule).")]
        public static bool <#= ReturnName #>_IsLeftIdentityForCompose(int arg0, float arg1)
        {
            Func<int, <#= Name #><int>> of = val => <#= Name #>.<#= ReturnName #>(val);
            Func<int, <#= Name #><float>> fun = val => <#= Name #>.<#= ReturnName #>(arg1 * val);

            var left = of.Compose(fun).Invoke(arg0);
            var right = fun(arg0);

            return left.Equals(right);
        }

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= ReturnName #> is a right identity for Bind (second monad rule).")]
        public static bool <#= ReturnName #>_IsRightIdentityForBind(int arg0)
        {
            var me = <#= Name #>.<#= ReturnName #>(arg0);

            var left = me.Bind(<#= Name #>.<#= ReturnName #>);
            var right = me;

            return left.Equals(right);
        }

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= ReturnName #> is a right identity for Compose (second monad rule).")]
        public static bool <#= ReturnName #>_IsRightIdentityForCompose(int arg0, float arg1)
        {
            Func<float, <#= Name #><float>> of = val => <#= Name #>.<#= ReturnName #>(val);
            Func<int, <#= Name #><float>> fun = val => <#= Name #>.<#= ReturnName #>(arg1 * val);

            var left = fun.Compose(of).Invoke(arg0);
            var right = fun(arg0);

            return left.Equals(right);
        }

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - Bind is associative (third monad law).")]
        public static bool Bind_IsAssociative(short arg0, int arg1, long arg2)
        {
            var me = <#= Name #>.Of(arg0);

            Func<short, <#= Name #><int>> f = val => <#= Name #>.<#= ReturnName #>(arg1);
            Func<int, <#= Name #><long>> g = val => <#= Name #>.<#= ReturnName #>(arg2);

            var left = me.Bind(f).Bind(g);
            var right = me.Bind(val => f(val).Bind(g));

            return left.Equals(right);
        }
<#+ if (HasZero) { #>

        [Fact]
        public static void Satisfies_MonadZeroRule()
        {
            // Arrange
            Func<int, <#= Name #><long>> kun = val => <#= Name #>.<#= ReturnName #>((long)2 * val);

            // Act
            var left = <#= Name #><int>.<#= ZeroName #>.Bind(kun);
            var right = <#= Name #><long>.<#= ZeroName #>;

            // Assert
            Assert.True(left.Equals(right));
        }

        [Fact]
        public static void Satisfies_MonadMoreRule()
        {
            // Act
            var leftSome = <#= Name #>.<#= ReturnName #>(1).Bind(val => <#= Name #><int>.<#= ZeroName #>);
            var leftNone = <#= Name #><int>.<#= ZeroName #>.Bind(val => <#= Name #><int>.<#= ZeroName #>);
            var right = <#= Name #><int>.<#= ZeroName #>;

            // Assert
            Assert.True(leftSome.Equals(right));
            Assert.True(leftNone.Equals(right));
        }
<#+ } // T4: End of HasZero. #>
<#+ if (HasZero && HasPlus) { #>

        [Fact]
        public static void Satisfies_MonadOrRule()
        {
            // Arrange
            var monad = <#= Name #>.<#= ReturnName #>(2);

            // Act
            var leftSome = monad.<#= PlusName #>(<#= Name #>.<#= ReturnName #>(1));
            var leftNone = monad.<#= PlusName #>(<#= Name #><int>.<#= ZeroName #>);
            var right = monad;

            // Assert
            Assert.True(leftSome.Equals(right));
            Assert.True(leftNone.Equals(right));
        }

        [Fact]
        public static void DoesNotSatisfyRightZeroForPlus()
        {
            // Arrange
            var monad = <#= Name #>.<#= ReturnName #>(2);

            // Act
            var leftSome = <#= Name #>.<#= ReturnName #>(1).<#= PlusName #>(monad);
            var leftNone = <#= Name #><int>.<#= ZeroName #>.<#= PlusName #>(monad);
            var right = monad;

            // Assert
            Assert.False(leftSome.Equals(right));   // NB: Fails here the "Unit is a right zero for Plus".
            Assert.True(leftNone.Equals(right));
        }
<#+ } // T4: End of HasZero && HasPlus. #>

        #endregion
    }
}
<#+
    } // T4: End of EmitFacts().
} // T4: End of MonadTemplate.

#>