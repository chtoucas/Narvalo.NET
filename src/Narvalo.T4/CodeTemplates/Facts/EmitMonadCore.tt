<#+

public partial class MonadTemplate
{
    public void EmitMonadCore()
    {
#>
    // T4: EmitMonadCore().
    public static partial class <#= Name #>Facts {
        internal sealed class tAttribute : FactAttribute {
            public tAttribute(string description) : base() {
                DisplayName = nameof(<#= Name #>) + " - " + description;
            }
        }

        internal sealed class TAttribute : TheoryAttribute {
            public TAttribute(string description) : base() {
                DisplayName = nameof(<#= Name #>) + " - " + description;
            }
        }

        internal sealed class qAttribute : PropertyAttribute {
            public qAttribute(string description) : base() {
                DisplayName = nameof(<#= Name #>) + " - " + description;
            }
        }

        [q("Ap.Apply is <#= MapName #>.Gather w/ the arguments flipped.")]
        public static bool Apply01(int arg0, long arg1) {
            var applicative = <#+ WriteFactory("Func<int, long>"); #>(i => arg1 * i);
            var value = <#+ WriteFactory("int"); #>(arg0);

            var applied = applicative.Apply(value);
            var gathered = value.Gather(applicative);

            return applied.Equals(gathered);
        }

        [q("Kleisli.InvokeWith is Qperators.SelectWith w/ the arguments flipped.", Skip = "Needs some more work.")]
        public static bool InvokeWith01(int arg0, long arg1, int arg3) {
            Func<int, <#= Name #><long<#= RTDecl #>>> selector = i => <#+ WriteFactory("long"); #>(arg1 * i);
            var seq = Enumerable.Repeat(arg0, arg3);

            var invoked = selector.InvokeWith(seq);
            var selected = seq.SelectWith(selector);

            var q = from x in invoked
                    from y in selected
                    select Enumerable.SequenceEqual(x, y);

            return q.<#= ValueProperty #>;
        }

        [q("Kleisli.InvokeWith is <#= Name #>.Bind w/ the arguments flipped.")]
        public static bool InvokeWith02(int arg0, long arg1) {
            Func<int, <#= Name #><long<#= RTDecl #>>> binder = i => <#+ WriteFactory("long"); #>(arg1 * i);
            var value = <#+ WriteFactory("int"); #>(arg0);

            var invoked = binder.InvokeWith(value);
            var bounded = value.Bind(binder);

            return invoked.Equals(bounded);
        }
    }
<#+
    } // T4: End of EmitMonadCore().
} // T4: End of MonadTemplate.

#>