<#+

public partial class MonadTemplate
{
    public void EmitMonadRules()
    {
#>
    // Provides tests for <#= Name #><T<#= RTDecl #>>: functor, monoid and monad laws.
    // T4: EmitRules().
    public static partial class <#= Name #>Facts
    {
        #region Functor Rules

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - The identity map is a fixed point for <#= MapName #> (first functor law).")]
        public static bool Identity_IsFixedPointFor<#= MapName #>(int arg)
        {
            var me = <#+ WriteFactory("int"); #>(arg);

            // fmap id  ==  id
            var left = me.<#= MapName #>(val => val);
            var right = me;

            return left.Equals(right);
        }

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= MapName #> preserves the composition operator (second functor law).")]
        public static bool <#= MapName #>_PreservesComposition(short arg, Func<short, int> g, Func<int, long> f)
        {
            var me = <#+ WriteFactory("short"); #>(arg);

            // fmap (f . g)  ==  fmap f . fmap g
            var left = me.<#= MapName #>(val => f(g(val)));
            var right = me.<#= MapName #>(g).<#= MapName #>(f);

           return left.Equals(right);
        }

        #endregion

<#+ if (HasZero && HasPlus) { #>
        #region Monoid Rules

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= ZeroName #> is a left identity for <#= PlusName #>.")]
        public static bool <#= ZeroName #>_IsLeftIdentityFor<#= PlusName #>(int arg)
        {
            var me = <#+ WriteFactory("int"); #>(arg);

            // mappend mempty x  ==  x
            var left = <#= Name #><int>.<#= ZeroName #>.<#= PlusName #>(me);
            var right = me;

            return left.Equals(right);
        }

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= ZeroName #> is a right identity for <#= PlusName #>.")]
        public static bool <#= ZeroName #>_IsRightIdentityFor<#= PlusName #>(int arg)
        {
            var me = <#+ WriteFactory("int"); #>(arg);

            // mappend x mempty ==  x
            var left = me.<#= PlusName #>(<#= Name #><int>.<#= ZeroName #>);
            var right = me;

            return left.Equals(right);
        }

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= PlusName #> is associative.")]
        public static bool <#= PlusName #>_IsAssociative(int arg0, int arg1, int arg2)
        {
            var x = <#+ WriteFactory("int"); #>(arg0);
            var y = <#+ WriteFactory("int"); #>(arg1);
            var z = <#+ WriteFactory("int"); #>(arg2);

            // mappend x (mappend y z)  ==  mappend (mappend x y) z
            var left = x.<#= PlusName #>(y.<#= PlusName #>(z));
            var right = x.<#= PlusName #>(y).<#= PlusName #>(z);

            return left.Equals(right);
        }

        #endregion

<#+ } // T4: End of HasZero && HasPlus. #>
        #region Monad Rules

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= ReturnName #> is a left identity for Bind (first monad law).")]
        public static bool <#= ReturnName #>_IsLeftIdentityForBind(int arg0, float arg1)
        {
            Func<int, <#= Name #><float<#= RTDecl #>>> f = val => <#+ WriteFactory("float"); #>(arg1 * val);

            // return a >>= k  ==  k a
            var left = <#+ WriteFactory("int"); #>(arg0).Bind(f);
            var right = f(arg0);

            return left.Equals(right);
        }

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= ReturnName #> is a left identity for Compose (first monad law).")]
        public static bool <#= ReturnName #>_IsLeftIdentityForCompose(int arg0, float arg1)
        {
            Func<int, <#= Name #><int<#= RTDecl #>>> of = <#+ WriteFactory("int"); #>;
            Func<int, <#= Name #><float<#= RTDecl #>>> f = val => <#+ WriteFactory("float"); #>(arg1 * val);

            // return >=> g  ==  g
            var left = of.Compose(f).Invoke(arg0);
            var right = f(arg0);

            return left.Equals(right);
        }

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= ReturnName #> is a right identity for Bind (second monad law).")]
        public static bool <#= ReturnName #>_IsRightIdentityForBind(int arg0)
        {
            var me = <#+ WriteFactory("int"); #>(arg0);

            // m >>= return  ==  m
            var left = me.Bind(<#+ WriteFactory("int"); #>);
            var right = me;

            return left.Equals(right);
        }

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= ReturnName #> is a right identity for Compose (second monad law).")]
        public static bool <#= ReturnName #>_IsRightIdentityForCompose(int arg0, float arg1)
        {
            Func<int, <#= Name #><float<#= RTDecl #>>> f = val => <#+ WriteFactory("float"); #>(arg1 * val);

            // f >=> return  ==  f
            var left = f.Compose(<#+ WriteFactory("float"); #>).Invoke(arg0);
            var right = f(arg0);

            return left.Equals(right);
        }

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - Bind is associative (third monad law).")]
        public static bool Bind_IsAssociative(short arg0, int arg1, long arg2)
        {
            var me = <#+ WriteFactory("short"); #>(arg0);

            Func<short, <#= Name #><int<#= RTDecl #>>> f = val => <#+ WriteFactory("int"); #>(arg1 * val);
            Func<int, <#= Name #><long<#= RTDecl #>>> g = val => <#+ WriteFactory("long"); #>(arg2 * val);

            // m >>= (\x -> f x >>= g)  ==  (m >>= f) >>= g
            var left = me.Bind(f).Bind(g);
            var right = me.Bind(val => f(val).Bind(g));

            return left.Equals(right);
        }

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - Compose is associative (third monad law).")]
        public static bool Compose_IsAssociative(short arg0, int arg1, long arg2, double arg3)
        {
            Func<short, <#= Name #><int<#= RTDecl #>>> f = val => <#+ WriteFactory("int"); #>(arg1 * val);
            Func<int, <#= Name #><long<#= RTDecl #>>> g = val => <#+ WriteFactory("long"); #>(arg2 * val);
            Func<long, <#= Name #><double<#= RTDecl #>>> h = val => <#+ WriteFactory("double"); #>(arg3 * val);

            // f >=> (g >=> h)  ==  (f >=> g) >=> h
            var left = f.Compose(g.Compose(h)).Invoke(arg0);
            var right = f.Compose(g).Compose(h).Invoke(arg0);

            return left.Equals(right);
        }

        #endregion
<#+ if (HasZero) { #>

        #region Monad Plus Rules

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= ZeroName #> is is a left zero for Bind (monad zero rule).")]
        public static bool <#= ZeroName #>_IsLeftZeroForBind(long arg0)
        {
            Func<int, <#= Name #><long>> f = val => <#+ WriteFactory("long"); #>(arg0 * val);

            // mzero >>= f  ==  mzero
            var left = <#= Name #><int>.<#= ZeroName #>.Bind(f);
            var right = <#= Name #><long>.<#= ZeroName #>;

            return left.Equals(right);
        }

        [Property(DisplayName = "<#= Name #><T<#= RTDecl #>> - <#= ZeroName #> is is a right zero for Bind (monad more rule).")]
        public static bool <#= ZeroName #>_IsRightZeroForBind(int arg0)
        {
            // m >>= (\x -> mzero) = mzero
            var left = <#+ WriteFactory("int"); #>(arg0).Bind(_ => <#= Name #><long>.<#= ZeroName #>);
            var right = <#= Name #><long>.<#= ZeroName #>;

            return left.Equals(right);
        }
<#+ } // T4: End of HasZero. #>
<#+ if (HasZero && HasPlus) { #>

        [Fact]
        public static void Satisfies_MonadOrRule()
        {
            // Arrange
            var monad = <#+ WriteFactory("int"); #>(2);

            // Act
            var leftSome = monad.<#= PlusName #>(<#+ WriteFactory("int"); #>(1));
            var leftNone = monad.<#= PlusName #>(<#= Name #><int>.<#= ZeroName #>);
            var right = monad;

            // Assert
            Assert.True(leftSome.Equals(right));
            Assert.True(leftNone.Equals(right));
        }

        [Fact]
        public static void DoesNotSatisfyRightZeroForPlus()
        {
            // Arrange
            var monad = <#+ WriteFactory("int"); #>(2);

            // Act
            var leftSome = <#+ WriteFactory("int"); #>(1).<#= PlusName #>(monad);
            var leftNone = <#= Name #><int>.<#= ZeroName #>.<#= PlusName #>(monad);
            var right = monad;

            // Assert
            Assert.False(leftSome.Equals(right));   // NB: Fails here the "Unit is a right zero for Plus".
            Assert.True(leftNone.Equals(right));
        }

        #endregion
<#+ } // T4: End of HasZero && HasPlus. #>
    }
<#+
    } // T4: End of EmitRules().
} // T4: End of MonadTemplate.

#>