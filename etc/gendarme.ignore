# Gendarme ignore file
# ====================
#
# R: Full name of a rule to be filtered.
# T: Used to filter out a fully qualified type name.
# M: Used to filter out a type member.
# N: Used to filter out a namespace.
# A: Used to filter out an assembly.
#
# NB: An ignore-file can be generated automatically (using gd2i) from an XML
# defect list produced by Gendarme.
#
# Sample ignore files from the Mono project:
# https://github.com/mono/mono-tools/blob/master/gendarme/mono-options.ignore
# https://github.com/mono/mono-tools/blob/master/gendarme/self-test.ignore

# Narvalo.Core
# ==============================================================================

R: Gendarme.Rules.Design.Generic.AvoidMethodWithUnusedGenericTypeRule
#  ------------------------------------------------------------------
# JUSTIFICATION = [Intentionally] There is no way we can achieve the same thing with type parameter inference.
M: Narvalo.Fx.Either`2<TLeft,TRight> Narvalo.Fx.Either::Left(TLeft)
M: Narvalo.Fx.Either`2<TLeft,TRight> Narvalo.Fx.Either::Right(TRight)
M: Narvalo.Fx.Switch`2<TLeft,TRight> Narvalo.Fx.Switch::Left(TLeft)
M: Narvalo.Fx.Switch`2<TLeft,TRight> Narvalo.Fx.Switch::Right(TRight)
M: System.Collections.Generic.IEnumerable`1<TSource> Narvalo.Fx.Sequence::Empty()

R: Gendarme.Rules.Design.Generic.DoNotDeclareStaticMembersOnGenericTypesRule
#  -------------------------------------------------------------------------
# JUSTIFICATION = [Ignore] An explicit conversion operator must be static.
M: Narvalo.Fx.Maybe`1<T> Narvalo.Fx.Maybe`1::op_Explicit(T)
M: T Narvalo.Fx.Maybe`1::op_Explicit(Narvalo.Fx.Maybe`1<T>)
M: System.Boolean Narvalo.Range`1::op_Equality(Narvalo.Range`1<T>,Narvalo.Range`1<T>)
M: System.Boolean Narvalo.Range`1::op_Inequality(Narvalo.Range`1<T>,Narvalo.Range`1<T>)

R: Gendarme.Rules.Design.Generic.DoNotExposeNestedGenericSignaturesRule
#  --------------------------------------------------------------------
# JUSTIFICATION = [Intentionally] Exposing nested generics is the price to pay for monads.
N: Narvalo.Fx
N: Narvalo.Fx.Extensions
N: Narvalo.Fx.Extensions.Internal

R: Gendarme.Rules.Exceptions.InstantiateArgumentExceptionCorrectlyRule
#  -------------------------------------------------------------------
# JUSTIFICATION = [Ignore] We do initialize the exceptions correctly, but Gendarme does not recognize that.
M: System.Void Narvalo.Enforce::GreaterThan(T,T,System.String)
M: System.Void Narvalo.Enforce::GreaterThanOrEqualTo(T,T,System.String)
M: System.Void Narvalo.Enforce::InRange(T,T,T,System.String)
M: System.Void Narvalo.Enforce::LessThan(T,T,System.String)
M: System.Void Narvalo.Enforce::LessThanOrEqualTo(T,T,System.String)
M: System.Void Narvalo.Require::GreaterThan(System.Int32,System.Int32,System.String)
M: System.Void Narvalo.Require::GreaterThan(System.Int64,System.Int64,System.String)
M: System.Void Narvalo.Require::GreaterThanOrEqualTo(System.Int32,System.Int32,System.String)
M: System.Void Narvalo.Require::GreaterThanOrEqualTo(System.Int64,System.Int64,System.String)
M: System.Void Narvalo.Require::InRange(System.Int32,System.Int32,System.Int32,System.String)
M: System.Void Narvalo.Require::InRange(System.Int64,System.Int64,System.Int64,System.String)
M: System.Void Narvalo.Require::LessThan(System.Int32,System.Int32,System.String)
M: System.Void Narvalo.Require::LessThan(System.Int64,System.Int64,System.String)
M: System.Void Narvalo.Require::LessThanOrEqualTo(System.Int32,System.Int32,System.String)
M: System.Void Narvalo.Require::LessThanOrEqualTo(System.Int64,System.Int64,System.String)
M: System.Void Narvalo.Require::NotNull(T,System.String)
M: System.Void Narvalo.Require::NotNullOrEmpty(System.String,System.String)
M: System.Void Narvalo.Require::NotNullOrWhiteSpace(System.String,System.String)

R: Gendarme.Rules.Naming.UseCorrectCasingRule
#  ------------------------------------------
# JUSTIFICATION = [Intentionally] Acceptable for namespaces. Narvalo.FX would appear plain ugly to me.
N: Narvalo.Fx
N: Narvalo.Fx.Extensions
N: Narvalo.Fx.Extensions.Internal
# JUSTIFICATION = [Intentionally] Standard naming convention from mathematics. Only used internally.
M: Narvalo.Fx.Either`2<TLeft,TRight> Narvalo.Fx.Either`2::η(TLeft)
M: Narvalo.Fx.Either`2<TLeft,TRight> Narvalo.Fx.Either`2::η(TRight)
M: Narvalo.Fx.Output`1<T> Narvalo.Fx.Output`1::η(T)
M: Narvalo.Fx.Output`1<T> Narvalo.Fx.Output`1::η(System.Runtime.ExceptionServices.ExceptionDispatchInfo)
M: Narvalo.Fx.Output`1<T> Narvalo.Fx.Output`1::μ(Narvalo.Fx.Output`1<Narvalo.Fx.Output`1<T>>)

R: Gendarme.Rules.Naming.ParameterNamesShouldMatchOverriddenMethodRule
#  -------------------------------------------------------------------
# JUSTIFICATION = [REVIEW]
M: Narvalo.Fx.Switch`2<TLeft,TResult> Narvalo.Fx.Switch`2/Empty_::Bind(System.Func`2<TRight,Narvalo.Fx.Switch`2<TLeft,TResult>>)
M: Narvalo.Fx.Switch`2<TLeft,TResult> Narvalo.Fx.Switch`2/Empty_::Map(System.Func`2<TRight,TResult>)
M: Narvalo.Fx.Switch`2<TLeft,TResult> Narvalo.Fx.Switch`2/Left_::Bind(System.Func`2<TRight,Narvalo.Fx.Switch`2<TLeft,TResult>>)
M: Narvalo.Fx.Switch`2<TLeft,TResult> Narvalo.Fx.Switch`2/Left_::Map(System.Func`2<TRight,TResult>)
M: Narvalo.Fx.Switch`2<TLeft,TResult> Narvalo.Fx.Switch`2/Right_::Bind(System.Func`2<TRight,Narvalo.Fx.Switch`2<TLeft,TResult>>)
M: Narvalo.Fx.Switch`2<TLeft,TResult> Narvalo.Fx.Switch`2/Right_::Map(System.Func`2<TRight,TResult>)

R: Gendarme.Rules.Performance.AvoidRepetitiveCallsToPropertiesRule
#  ---------------------------------------------------------------
# JUSTIFICATION = [FIXME] Correct. See how it is done in System.Linq.Enumerable.
M: Narvalo.Fx.Maybe`1<TSource> Narvalo.Fx.EnumerableExtensions::LastOrNone(System.Collections.Generic.IEnumerable`1<TSource>,System.Func`2<TSource,System.Boolean>)
M: TSource Narvalo.Fx.EnumerableExtensions::Reduce(System.Collections.Generic.IEnumerable`1<TSource>,System.Func`3<TSource,TSource,TSource>,System.Func`2<TSource,System.Boolean>)

R: Gendarme.Rules.Performance.AvoidUncalledPrivateCodeRule
#  -------------------------------------------------------
# JUSTIFICATION = [REVIEW]
M: Narvalo.Fx.Either`2<TLeft,TRight> Narvalo.Fx.Either`2::η(TRight)
M: Narvalo.Fx.Output`1<T> Narvalo.Fx.Output`1::η(System.Runtime.ExceptionServices.ExceptionDispatchInfo)
M: Narvalo.Fx.Switch`2<TLeft,TRight> Narvalo.Fx.Switch`2::η(TRight)

R: Gendarme.Rules.Performance.AvoidUninstantiatedInternalClassesRule
#  -----------------------------------------------------------------
# JUSTIFICATION = [REVIEW]
T: Narvalo.Internal.ValidatedNotNullAttribute

R: Gendarme.Rules.Smells.AvoidCodeDuplicatedInSameClassRule
#  --------------------------------------------------------
# JUSTIFICATION = [REVIEW]
M: System.Int64 Narvalo.Int64Encoder::FromFlickrBase58String(System.String)

R: Gendarme.Rules.Smells.AvoidLongParameterListsRule
#  -------------------------------------------------
# JUSTIFICATION = [Intentionally] Correct but these are helper methods for private use only.
M: Narvalo.Fx.Maybe`1<TResult> Narvalo.Fx.Maybe::JoinCore_(Narvalo.Fx.Maybe`1<TSource>,Narvalo.Fx.Maybe`1<TInner>,System.Func`2<TSource,TKey>,System.Func`2<TInner,TKey>,System.Func`3<TSource,TInner,TResult>,System.Collections.Generic.IEqualityComparer`1<TKey>)
M: Narvalo.Fx.Maybe`1<TResult> Narvalo.Fx.Maybe::GroupJoinCore_(Narvalo.Fx.Maybe`1<TSource>,Narvalo.Fx.Maybe`1<TInner>,System.Func`2<TSource,TKey>,System.Func`2<TInner,TKey>,System.Func`3<TSource,Narvalo.Fx.Maybe`1<TInner>,TResult>,System.Collections.Generic.IEqualityComparer`1<TKey>)

R: Gendarme.Rules.Smells.AvoidSpeculativeGeneralityRule
#  ----------------------------------------------------
# JUSTIFICATION = [REVIEW]
T: Narvalo.Fx.Either
T: Narvalo.Fx.Switch
T: Narvalo.Int64Encoder
T: Narvalo.Fx.Extensions.FuncMaybeExtensions
T: Narvalo.Fx.Extensions.FuncNullableExtensions
T: Narvalo.Fx.Extensions.PredicateExtensions
